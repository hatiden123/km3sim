//
// ********************************************************************
// * DISCLAIMER                                                       *
// *                                                                  *
// * The following disclaimer summarizes all the specific disclaimers *
// * of contributors to this software. The specific disclaimers,which *
// * govern, are listed with their locations in:                      *
// *   http://cern.ch/geant4/license                                  *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.                                                             *
// *                                                                  *
// * This  code  implementation is the  intellectual property  of the *
// * GEANT4 collaboration.                                            *
// * By copying,  distributing  or modifying the Program (or any work *
// * based  on  the Program)  you indicate  your  acceptance of  this *
// * statement, and all its terms.                                    *
// ********************************************************************
//
//

#include "KM3PrimaryGeneratorAction.hh"

#include "globals.hh"
#include "G4Event.hh"
#include "G4HEPEvtInterface.hh"
#include "G4PrimaryParticle.hh"
#include "G4PrimaryVertex.hh"
#include "Randomize.hh"
#include "G4ParticleDefinition.hh"
#include "G4ParticleTypes.hh"

#ifdef G4MYEM_PARAMETERIZATION
#include "G4Material.hh"
#include "G4MaterialPropertiesTable.hh"
#endif

KM3PrimaryGeneratorAction::KM3PrimaryGeneratorAction() {}

KM3PrimaryGeneratorAction::~KM3PrimaryGeneratorAction() {
  if (useHEPEvt)
    delete HEPEvt;
#ifdef G4MYMUON_PARAMETERIZATION
  else
    delete myMuonParam; // for muon param vs distance
#endif
}

void KM3PrimaryGeneratorAction::Initialize() {
  if (useHEPEvt)
    HEPEvt = new G4HEPEvtInterface(filePythiaParticles);
#ifdef G4MYMUON_PARAMETERIZATION
  else
    myMuonParam = new KM3MuonParam(); // for muon param vs distance
#endif
#ifndef G4MYFIT_PARAMETERIZATION
#ifndef G4MYEM_PARAMETERIZATION
#if (defined(G4MYHA_PARAMETERIZATION) &&                                       \
     defined(G4MYHAMUONS_PARAMETERIZATION)) ||                                 \
    !defined(G4MYHA_PARAMETERIZATION)
  infile = fopen(fileParticles, "r"); // it contains the number of events, the
                                      // particle type, the vertex and momentum
                                      // information
  G4double runtime;
  fscanf(infile, "%d %lf\n", &nevents, &runtime);
#endif
#ifndef G4MYHA_PARAMETERIZATION
#ifdef G4HADRONIC_COMPILE
  aHAVertexMuons =
      new HAVertexMuons("TheMuons_Hadron.dat", "TheMuons_Hadron.index");
#endif
#endif
#endif
#endif
  if (outfile == NULL)
    G4cout << "ERROR OUTFILE\n" << G4endl;
}
// primary particle generation. Single, multiple (many vertexes) particles and
// neutrino interaction events (single vertex) are supported
// that covers almost everything, except exotic particles (monopoles etc)
void KM3PrimaryGeneratorAction::GeneratePrimaries(G4Event *anEvent) {
  static G4int ievent = 0;
  G4int idneu; // type of neutrino interacting (PDG Code)
  G4int idtarget; // type of target if neutrino interaction (PDG Code)
  G4double xneu, yneu, zneu; // neutrino vertex (cm) if neutrino interaction
  G4double pxneu, pyneu,
      pzneu; // neutrino momentum (GeV/c) if neutrino interaction
  G4int idbeam; // type of injected or produced particles (PDG Code)
  G4double xx0, yy0, zz0; // Vertex of injected or produced particles (in cm)
  G4double pxx0, pyy0,
      pzz0; // Momentum of injected or produced particles (in GeV/c)
  G4double t0; // initial time of injected particles(ns)
  ievent++;
#ifndef G4MYFIT_PARAMETERIZATION
#ifndef G4MYEM_PARAMETERIZATION
#if (defined(G4MYHA_PARAMETERIZATION) &&                                       \
     defined(G4MYHAMUONS_PARAMETERIZATION)) ||                                 \
    !defined(G4MYHA_PARAMETERIZATION)
#ifndef G4MYHA_PARAMETERIZATION // newha
  event_action->Initialize();
#endif
  if (ievent == 1)
    fprintf(outfile, "%d\n", nevents); // write the number of events
  if (!useHEPEvt) {
    idtarget = 0; // the target id is not relevant in case of injected
                  // particles.
    idneu = 0; // neither is the neutrino id
    xneu = 0.0;
    yneu = 0.0;
    zneu = 0.0; // or the neutrino interaction vertex
    pxneu = 0.0;
    pyneu = 0.0;
    pzneu = 0.0; // or the neutrino momentum
    fprintf(outfile, "%d %d %d\n", ievent, idneu, idtarget);
    fprintf(outfile, "%.6e %.6e %.6e %.6e %.6e %.6e\n", xneu, yneu, zneu, pxneu,
            pyneu, pzneu);
    fscanf(infile, "%d\n", &numberofParticles);
#ifdef G4MYMUON_PARAMETERIZATION
    // newcode for muon param vs distance // applicable only for simulation of
    // atmospheric muons from EAS
    G4int idbeams[7000];
    G4double t0s[7000], energies[7000], distances[7000];
    std::vector<G4ThreeVector> theMuonsPositions;
    std::vector<G4ThreeVector> theMuonsMomenta;
    std::vector<G4ThreeVector> theMuonsDirections;
    for (G4int ipart = 0; ipart < numberofParticles; ipart++) {
      fscanf(infile, "%d %lf %lf %lf %lf %lf %lf %lf\n", &idbeams[ipart], &xx0,
             &yy0, &zz0, &pxx0, &pyy0, &pzz0, &t0s[ipart]);
      theMuonsPositions.push_back(G4ThreeVector(xx0 * cm, yy0 * cm, zz0 * cm));
      theMuonsMomenta.push_back(
          G4ThreeVector(pxx0 * GeV, pyy0 * GeV, pzz0 * GeV));
      theMuonsDirections.push_back(theMuonsMomenta[ipart].unit());
      t0s[ipart] *= ns;
      energies[ipart] = theMuonsMomenta[ipart].mag();
      // here find the distance to cross the can

      G4ThreeVector distanceV = theMuonsPositions[ipart] - detectorCenter;
      G4double RRR2 = detectorMaxRho * detectorMaxRho;

      distances[ipart] = -1.0;
      // next check if is going to hit the top of the detector
      G4double Ttop = (detectorMaxz - theMuonsPositions[ipart][2]) /
                      theMuonsDirections[ipart][2];
      if (Ttop > 0) {
        G4ThreeVector PointOnTop(
            distanceV[0] + Ttop * theMuonsDirections[ipart][0],
            distanceV[1] + Ttop * theMuonsDirections[ipart][1],
            distanceV[2] + Ttop * theMuonsDirections[ipart][2]);

        G4double dRhoTop =
            PointOnTop[0] * PointOnTop[0] + PointOnTop[1] * PointOnTop[1];
        if (dRhoTop < RRR2)
          distances[ipart] = Ttop;

        // next check if is going to hit the side of the detector
        G4double c =
            distanceV[0] * distanceV[0] + distanceV[1] * distanceV[1] - RRR2;
        if (c > 0.0 && distances[ipart] < 0) {
          G4double a =
              theMuonsDirections[ipart][0] * theMuonsDirections[ipart][0] +
              theMuonsDirections[ipart][1] * theMuonsDirections[ipart][1];
          G4double b = distanceV[0] * theMuonsDirections[ipart][0] +
                       distanceV[1] * theMuonsDirections[ipart][1];
          G4double dia = b * b - a * c;
          if (dia > 0) {
            dia = sqrt(dia);
            G4double SideDist1 = (-b - dia) / a;
            G4double sidez1 = theMuonsPositions[ipart][2] +
                              SideDist1 * theMuonsDirections[ipart][2];
            if ((sidez1 > bottomPosition) && (sidez1 < detectorMaxz) &&
                (SideDist1 > 0))
              distances[ipart] = SideDist1;
          }
        }
      }
    }
    // check if there is any muon that can cross the detector
    G4double distancemax = -1.e9;
    for (G4int ipart = 0; ipart < numberofParticles; ipart++) {
      if (distances[ipart] > distancemax)
        distancemax = distances[ipart];
    }
    if (distancemax <
        0.0) { // no muon that moves to the detector. put a null muon
      numberofParticles = 1;
      EventWeight = 1.0;
      fprintf(outfile, "%d %.6e\n", numberofParticles, EventWeight);
      G4PrimaryParticle *initialParticle =
          new G4PrimaryParticle(idbeams[0], 0.0, 0.0, 0.01 * GeV);
      G4PrimaryVertex *vertex =
          new G4PrimaryVertex(theMuonsPositions[0], t0s[0]);
      vertex->SetPrimary(initialParticle);
      anEvent->AddPrimaryVertex(vertex);
      G4cout << "Generating vertex with x0= " << theMuonsPositions[0][0]
             << " y0= " << theMuonsPositions[0][1]
             << " z0= " << theMuonsPositions[0][2] << G4endl;
      G4cout << "Generating null particle with px0= 0.0 py0= 0.0 pz0= 10.0MeV "
             << ievent << G4endl;
      // write the beam and target ids (PDG codes), the vertex (cm), momentum
      // (GeV/c)
      fprintf(outfile, "%d %.6e %.6e %.6e 0.0 0.0 0.01 %.6e\n", idbeams[0],
              theMuonsPositions[0][0] / cm, theMuonsPositions[0][1] / cm,
              theMuonsPositions[0][2] / cm, t0s[0]);
      if ((idbeams[0] == 13) || (idbeams[0] == -13)) {
        event_action->AddPrimaryNumber(1);
      }
    } else { // there are some particles moving to the detector. Consider only
             // the ones that move to.
      for (G4int ipart = 0; ipart < numberofParticles; ipart++) {
        if (distances[ipart] >= 0.0)
          myMuonParam->AddMuon(energies[ipart], distances[ipart]);
      }
      myMuonParam->Initialize();
      // find if there are any capable particles
      G4int numcapable = 0;
      G4int ip = 0;
      for (G4int ipart = 0; ipart < numberofParticles; ipart++) {
        if (distances[ipart] >= 0.0) {
          if (myMuonParam->IsCapable(ip))
            numcapable++;
          ip++;
        }
      }
      if (numcapable ==
          0) { // no muon capable to reach the detector. put a null muon
        numberofParticles = 1;
        EventWeight = 1.0;
        fprintf(outfile, "%d %.6e\n", numberofParticles, EventWeight);
        G4PrimaryParticle *initialParticle =
            new G4PrimaryParticle(idbeams[0], 0.0, 0.0, 0.01 * GeV);
        G4PrimaryVertex *vertex =
            new G4PrimaryVertex(theMuonsPositions[0], t0s[0]);
        vertex->SetPrimary(initialParticle);
        anEvent->AddPrimaryVertex(vertex);
        G4cout << "Generating vertex with x0= " << theMuonsPositions[0][0]
               << " y0= " << theMuonsPositions[0][1]
               << " z0= " << theMuonsPositions[0][2] << G4endl;
        G4cout
            << "Generating null particle with px0= 0.0 py0= 0.0 pz0= 10.0MeV "
            << ievent << G4endl;
        // write the beam and target ids (PDG codes), the vertex (cm), momentum
        // (GeV/c)
        fprintf(outfile, "%d %.6e %.6e %.6e 0.0 0.0 0.01 %.6e\n", idbeams[0],
                theMuonsPositions[0][0] / cm, theMuonsPositions[0][1] / cm,
                theMuonsPositions[0][2] / cm, t0s[0]);
        if ((idbeams[0] == 13) || (idbeams[0] == -13)) {
          event_action->AddPrimaryNumber(1);
        }
      } else { // there are some muons capable to reach the detector. Consider
               // only the ones that can.
        G4int numberofParticleskeep = numberofParticles;
        do {
          numberofParticles = 0;
          ip = 0;
          for (G4int ipart = 0; ipart < numberofParticleskeep; ipart++) {
            if (distances[ipart] >= 0.0) {
              if (myMuonParam->IsCapable(ip)) {
                distances[ipart] = myMuonParam->GetDistance(ip);
                energies[ipart] = myMuonParam->GetEnergy(ip);
                if (energies[ipart] > 0.0)
                  numberofParticles++;
              } else
                energies[ipart] = -1.0;
              ip++;
            }
          }
        } while (numberofParticles <= 0);
        EventWeight = myMuonParam->GetWeight();
        fprintf(outfile, "%d %.6e\n", numberofParticles, EventWeight);
        ip = 0;
        for (G4int ipart = 0; ipart < numberofParticleskeep; ipart++) {
          if (distances[ipart] >= 0.0) {
            if (energies[ipart] > 0.0) {
              G4cout << "FERtest " << distances[ipart] << " " << energies[ipart]
                     << G4endl;
              theMuonsMomenta[ipart] =
                  energies[ipart] * theMuonsDirections[ipart];
              theMuonsPositions[ipart] +=
                  distances[ipart] * theMuonsDirections[ipart];
              t0s[ipart] += distances[ipart] / c_light;
              G4PrimaryParticle *initialParticle = new G4PrimaryParticle(
                  idbeams[ipart], theMuonsMomenta[ipart][0],
                  theMuonsMomenta[ipart][1], theMuonsMomenta[ipart][2]);
              G4PrimaryVertex *vertex =
                  new G4PrimaryVertex(theMuonsPositions[ipart], t0s[ipart]);
              vertex->SetPrimary(initialParticle);
              anEvent->AddPrimaryVertex(vertex);
              G4cout << "Generating vertex with x0= "
                     << theMuonsPositions[ipart][0]
                     << " y0= " << theMuonsPositions[ipart][1]
                     << " z0= " << theMuonsPositions[ipart][2] << G4endl;
              G4cout << "Generating particle with px0= "
                     << theMuonsMomenta[ipart][0]
                     << " py0= " << theMuonsMomenta[ipart][1]
                     << " pz0= " << theMuonsMomenta[ipart][2] << "MeV "
                     << ievent << G4endl;
              // write the beam and target ids (PDG codes), the vertex (cm),
              // momentum (GeV/c)
              fprintf(outfile, "%d %.6e %.6e %.6e %.6e %.6e %.6e %.6e\n",
                      idbeams[ipart], theMuonsPositions[ipart][0] / cm,
                      theMuonsPositions[ipart][1] / cm,
                      theMuonsPositions[ipart][2] / cm,
                      theMuonsMomenta[ipart][0] / GeV,
                      theMuonsMomenta[ipart][1] / GeV,
                      theMuonsMomenta[ipart][2] / GeV, t0s[ipart]);
              if ((idbeams[ipart] == 13) || (idbeams[ipart] == -13)) {
                event_action->AddPrimaryNumber(ip + 1);
              }
              ip++;
            }
          }
        }
      }
      myMuonParam->Finalize(); // stop using the muon distance-energy param
    }
// newcode for muon param vs distance
// ///////////////////////////////////////////////////////////////
#else
    // old code
    // ///////////////////////////////////////////////////////////////////////////////////////
    EventWeight = 1.0;
    fprintf(outfile, "%d %.6e\n", numberofParticles, EventWeight);
    for (G4int ipart = 0; ipart < numberofParticles; ipart++) {
      // define the particle object and properties from the particle PDG code
      // idbeam
      fscanf(infile, "%d %lf %lf %lf %lf %lf %lf %lf\n", &idbeam, &xx0, &yy0,
             &zz0, &pxx0, &pyy0, &pzz0, &t0);
      G4PrimaryParticle *initialParticle =
          new G4PrimaryParticle(idbeam, pxx0 * GeV, pyy0 * GeV, pzz0 * GeV);
      G4PrimaryVertex *vertex = new G4PrimaryVertex(
          G4ThreeVector(xx0 * cm, yy0 * cm, zz0 * cm), t0 * ns);
      vertex->SetPrimary(initialParticle);
      anEvent->AddPrimaryVertex(vertex);
      G4cout << "Generating vertex with x0=" << xx0 << " y0=" << yy0
             << " z0=" << zz0 << G4endl;
      G4cout << "Generating particle with px0=" << pxx0 << " py0=" << pyy0
             << " pz0=" << pzz0 << " " << ievent << G4endl;
      // write the beam and target ids (PDG codes), the vertex (cm), momentum
      // (GeV/c)
      fprintf(outfile, "%d %.6e %.6e %.6e %.6e %.6e %.6e %.6e\n", idbeam, xx0,
              yy0, zz0, pxx0, pyy0, pzz0, t0);
#ifndef G4MYHA_PARAMETERIZATION // newha
      if ((idbeam == 13) || (idbeam == -13)) {
        event_action->AddPrimaryNumber(ipart + 1);
      }
#endif
    }
// old code
// ///////////////////////////////////////////////////////////////////////////////////////////
#endif
  }
#endif
#endif
#endif
#ifdef G4MYFIT_PARAMETERIZATION
  event_action->Initialize();
  if (!useHEPEvt) {
    numberofParticles = 1;
    idbeam = 13; // muon minus
    G4PrimaryParticle *initialParticle =
        new G4PrimaryParticle(idbeam, 0.0, 0.0, -ParamEnergy);
    G4PrimaryVertex *vertex =
        new G4PrimaryVertex(G4ThreeVector(0.0, 0.0, 350.0 * meter), 0.0);
    vertex->SetPrimary(initialParticle);
    anEvent->AddPrimaryVertex(vertex);
    event_action->AddPrimaryNumber(1);
    G4cout << "Generating one event " << ievent << G4endl;
  }
#endif
#if defined(G4MYHA_PARAMETERIZATION) && !defined(G4MYHAMUONS_PARAMETERIZATION)
  if (!useHEPEvt) {
    position[0] = 0.0;
    position[1] = 0.0;
    position[2] = 0.0;
    G4PrimaryVertex *vertex = new G4PrimaryVertex(position, 0.0);
    G4double phi = 2.0 * pi * G4UniformRand();
    G4double costheta = 2.0 * G4UniformRand() - 1.0;
    G4double sintheta = sqrt(1.0 - costheta * costheta);
    G4double cosphi = cos(phi);
    G4double sinphi = sin(phi);
    direction[0] = sintheta * cosphi;
    direction[1] = sintheta * sinphi;
    direction[2] = costheta;
    numberofParticles = 1;
    idbeam = 211; // pion plus
    //    idbeam=321; //kaon plus
    //    idbeam=130; // kaon zero long
    //    idbeam=2112; //Neutron
    //    idbeam=2212; //Proton
    G4PrimaryParticle *initialParticle = new G4PrimaryParticle(
        idbeam, ParamEnergy * direction[0], ParamEnergy * direction[1],
        ParamEnergy * direction[2]);
    vertex->SetPrimary(initialParticle);
    anEvent->AddPrimaryVertex(vertex);
    G4cout << "Generating one event " << ievent << G4endl;
  }
#endif
#ifdef G4MYK40_PARAMETERIZATION
  if (!useHEPEvt) {
    //-----------------antonis-------------------------//
    position[0] = 0.0; // vertex position x
    position[1] = 0.0; // vertex position y
    position[2] = 0.0; // vertex position z
    G4PrimaryVertex *vertex = new G4PrimaryVertex(position, 0.0);
    G4double phi = 2.0 * pi * G4UniformRand();
    G4double costheta = 2.0 * G4UniformRand() - 1.0;
    G4double sintheta = sqrt(1.0 - costheta * costheta);
    G4double cosphi = cos(phi);
    G4double sinphi = sin(phi);
    direction[0] = sintheta * cosphi; // direction x
    direction[1] = sintheta * sinphi; // direction y
    direction[2] = costheta; // direction z
    numberofParticles = 1;
    idbeam = 11; // electron (-11 is positron and 22 is gamma)
    G4PrimaryParticle *initialParticle = new G4PrimaryParticle(
        idbeam, ParamEnergy * direction[0], ParamEnergy * direction[1],
        ParamEnergy * direction[2]);
    vertex->SetPrimary(initialParticle);
    anEvent->AddPrimaryVertex(vertex);
    G4cout << "Generating one K40 event " << ievent << G4endl;
    //-----------------antonis-------------------------//
  }
#endif
#if defined(G4MYEM_PARAMETERIZATION) && !defined(G4MYK40_PARAMETERIZATION)
  if (!useHEPEvt) {
    position[0] = 0.0;
    position[1] = 0.0;
    position[2] = 0.0;
    G4PrimaryVertex *vertex = new G4PrimaryVertex(position, 0.0);
    G4double phi = 2.0 * pi * G4UniformRand();
    G4double costheta = 2.0 * G4UniformRand() - 1.0;
    G4double sintheta = sqrt(1.0 - costheta * costheta);
    G4double cosphi = cos(phi);
    G4double sinphi = sin(phi);
    direction[0] = sintheta * cosphi;
    direction[1] = sintheta * sinphi;
    direction[2] = costheta;
    if (ParamEnergy > 0.0) {
      numberofParticles = 1;
      idbeam = 11; // electron
      G4PrimaryParticle *initialParticle = new G4PrimaryParticle(
          idbeam, ParamEnergy * direction[0], ParamEnergy * direction[1],
          ParamEnergy * direction[2]);
      vertex->SetPrimary(initialParticle);
    } else if (ParamEnergy == -1000.0) { // here is the parametrization for
                                         // delta rays of low energy
      static G4double specin = -0.9832; // this is the (1+a) where a=-1.9832 the
                                        // spectral index of muIoni generated
                                        // electrons (kinetic energy)
      static G4double emin = pow(0.24, specin); // minimum kinetic energy
                                                // 0.24MeV (threshold for
                                                // cherenkov production
      static G4double emax = pow(31.6, specin); // maximum kinetic energy (above
                                                // that em parametrization takes
                                                // over)
      numberofParticles = 10000;
      idbeam = 11; // electron
      for (G4int ip = 0; ip < numberofParticles; ip++) {
        G4double enekin = emin + G4UniformRand() * (emax - emin);
        enekin = pow(enekin, 1.0 / specin);
        G4double SpecMom =
            sqrt((enekin + 0.511) * (enekin + 0.511) -
                 0.511 * 0.511); // 0.511 is the electron mass in MeV
        G4double enelog = log10(enekin);
        G4double costheta =
            0.70351 +
            enelog *
                (0.40702 +
                 enelog *
                     (-0.12039 +
                      enelog *
                          (-0.92576e-1 +
                           enelog * (0.64971e-1 -
                                     0.98130e-2 * enelog)))); // angle vs kinene
        if (costheta > 1.0)
          costheta = 1.0;
        G4double sintheta = sqrt(1.0 - costheta * costheta);
        G4double phi = 2.0 * pi * G4UniformRand();
        G4double cosphi = cos(phi);
        G4double sinphi = sin(phi);
        G4ThreeVector electronMomentum(SpecMom * sintheta * cosphi,
                                       SpecMom * sintheta * sinphi,
                                       SpecMom * costheta);
        electronMomentum.rotateUz(direction);
        G4PrimaryParticle *initialParticle =
            new G4PrimaryParticle(idbeam, electronMomentum[0],
                                  electronMomentum[1], electronMomentum[2]);
        vertex->SetPrimary(initialParticle);
      }
    } else {
      /// at first initialize the pointers to Rindex,Q_E, glass and gell
      /// transparencies////
      static const G4MaterialPropertyVector *QECathod = NULL;
      static const G4MaterialPropertyVector *Rindex = NULL;
#ifdef G4MY_TRANSPARENCIES
      static const G4MaterialPropertyVector *AbsBenth = NULL;
      static const G4MaterialPropertyVector *AbsGell = NULL;
#endif
      if (QECathod == NULL) {
        const G4MaterialTable *theMaterialTable =
            G4Material::GetMaterialTable();
        for (size_t J = 0; J < theMaterialTable->size(); J++) {
          if ((*theMaterialTable)[J]->GetName() == G4String("Cathod")) {
            G4MaterialPropertiesTable *aMaterialPropertiesTable =
                (*theMaterialTable)[J]->GetMaterialPropertiesTable();
            QECathod = aMaterialPropertiesTable->GetProperty("Q_EFF");
          } else if ((*theMaterialTable)[J]->GetName() == G4String("Water")) {
            G4MaterialPropertiesTable *aMaterialPropertiesTable =
                (*theMaterialTable)[J]->GetMaterialPropertiesTable();
            Rindex = aMaterialPropertiesTable->GetProperty("RINDEX");
          }
#ifdef G4MY_TRANSPARENCIES
          else if ((*theMaterialTable)[J]->GetName() == G4String("Glass")) {
            G4MaterialPropertiesTable *aMaterialPropertiesTable =
                (*theMaterialTable)[J]->GetMaterialPropertiesTable();
            AbsBenth = aMaterialPropertiesTable->GetProperty("ABSLENGTH");
          } else if ((*theMaterialTable)[J]->GetName() == G4String("Gell")) {
            G4MaterialPropertiesTable *aMaterialPropertiesTable =
                (*theMaterialTable)[J]->GetMaterialPropertiesTable();
            AbsGell = aMaterialPropertiesTable->GetProperty("ABSLENGTH");
          }
#endif
        }
      }
      /// end of
      /// initialization//////////////////////////////////////////////////////
      G4ParticleDefinition *OPDefinition =
          G4OpticalPhoton::OpticalPhotonDefinition();
      numberofParticles = 0;
      idbeam = 0; // Optical Photon . is not used , because it has not a
                  // pdgcoding in geant4
      for (G4int ip = 0; ip < 100000;
           ip++) { // 100000 is the number of photns before the QE and
                   // transparencies

        // sample an optical
        // photon//////////////////////////////////////////////
        G4double nMax = Rindex->GetMaxProperty();
        G4double maxCos = 1.0 / nMax;
        G4double Pmin = Rindex->GetMinPhotonEnergy();
        G4double Pmax = Rindex->GetMaxPhotonEnergy();
        G4double dp = Pmax - Pmin;
        G4double maxSin2 = (1.0 - maxCos) * (1.0 + maxCos);

        G4double rand;
        G4double sampledMomentum, sampledRI;
        G4double cosTheta, sin2Theta;

        // sample a phi
        rand = G4UniformRand();
        G4double phi = 2.0 * pi * rand;
        G4double sinPhi = sin(phi);
        G4double cosPhi = cos(phi);

        // Determine photon momentum
        // sample a momentum

        do {
          rand = G4UniformRand();
          sampledMomentum = Pmin + rand * dp;
          sampledRI = Rindex->GetProperty(sampledMomentum);
          cosTheta = 1.0 / sampledRI;

          sin2Theta = (1.0 - cosTheta) * (1.0 + cosTheta);
          rand = G4UniformRand();

        } while (rand * maxSin2 > sin2Theta);
        G4double qeProb = QECathod->GetProperty(sampledMomentum);
#ifdef G4MY_TRANSPARENCIES
        qeProb *= exp(-15.0 / AbsBenth->GetProperty(sampledMomentum) -
                      10.0 / AbsGell->GetProperty(sampledMomentum));
#endif
        if (G4UniformRand() < qeProb) {
          numberofParticles++;
          G4double sinTheta = sqrt(sin2Theta);
          G4double px = sampledMomentum * sinTheta * cosPhi;
          G4double py = sampledMomentum * sinTheta * sinPhi;
          G4double pz = sampledMomentum * cosTheta;

          // Create photon momentum direction vector
          // The momentum direction is still with respect
          // to the coordinate system where the primary
          // particle direction is aligned with the z axis

          G4ThreeVector photonMomentum(px, py, pz);

          // Rotate momentum direction back to global reference
          // system

          photonMomentum.rotateUz(direction);
          // Determine polarization of new photon

          G4double sx = cosTheta * cosPhi;
          G4double sy = cosTheta * sinPhi;
          G4double sz = -sinTheta;

          G4ThreeVector photonPolarization(sx, sy, sz);

          // Rotate back to original coord system

          photonPolarization.rotateUz(direction);
          // create the photon as primary
          G4PrimaryParticle *initialParticle =
              new G4PrimaryParticle(OPDefinition, photonMomentum[0],
                                    photonMomentum[1], photonMomentum[2]);
          initialParticle->SetPolarization(photonPolarization[0],
                                           photonPolarization[1],
                                           photonPolarization[2]);
          vertex->SetPrimary(initialParticle);
        }
        ////////////////////////////////////////////////////////////////////////////
      }
      G4cout << "Number of photons " << numberofParticles << G4endl;
    }
    anEvent->AddPrimaryVertex(vertex);
    G4cout << "Generating one event " << ievent << G4endl;
  }
#endif
#ifndef G4MYFIT_PARAMETERIZATION
#ifndef G4MYEM_PARAMETERIZATION
#ifndef G4MYHA_PARAMETERIZATION
  else {
    t0 = 0.0; // starting particle time is common in neutrino interaction
    fscanf(infile, "%d %d %lf %lf %lf %lf %lf %lf\n", &idneu, &idtarget, &xneu,
           &yneu, &zneu, &pxneu, &pyneu, &pzneu);
    // Generate the Event (reads from Pythia output file)
    HEPEvt->GeneratePrimaryVertex(anEvent);
    // Change the position of the vertex of the event
    anEvent->GetPrimaryVertex(0)->SetPosition(xneu * cm, yneu * cm, zneu * cm);
    numberofParticles = anEvent->GetPrimaryVertex(0)->GetNumberOfParticle();
    fprintf(outfile, "%d %d %d\n", ievent, idneu,
            idtarget); // write the event number (starting with 1) , the beam
                       // and target ids (PDG codes)
    fprintf(outfile, "%.6e %.6e %.6e %.6e %.6e %.6e\n", xneu, yneu, zneu, pxneu,
            pyneu, pzneu); // write the vertex (cm), momentum (GeV/c)
    EventWeight = 1.0;
    fprintf(outfile, "%d %.6e\n", numberofParticles, EventWeight);
    for (G4int ipart = 0; ipart < numberofParticles; ipart++) {
      idbeam = anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetPDGcode();
      pxx0 = anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetPx() / GeV;
      pyy0 = anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetPy() / GeV;
      pzz0 = anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetPz() / GeV;
      fprintf(outfile, "%d %.6e %.6e %.6e %.6e %.6e %.6e %.6e\n", idbeam, xneu,
              yneu, zneu, pxx0, pyy0, pzz0,
              t0); // vertex position is common in neutrino interaction
      if ((idbeam == 13) || (idbeam == -13)) {
        event_action->AddPrimaryNumber(ipart + 1);
      }
    }
#ifdef G4HADRONIC_COMPILE
    // here only if hadronic interactions are used add muons from hadronic
    // vertex
    // but first calculate the energy of hadrons
    direction = G4ThreeVector(0.0, 0.0, 0.0);
    G4double HadronicEnergy = 0.0;
    for (G4int ipart = 0; ipart < numberofParticles; ipart++) {
      idbeam =
          fabs(anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetPDGcode());
      if (idbeam != 22 && idbeam != 13 && idbeam != 11 && idbeam != 15 &&
          idbeam != 111) { // disregard em particles
        G4ThreeVector thisMomentum =
            anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetMomentum();
        G4double thisMass =
            anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetMass();
        G4double Energy = sqrt(thisMomentum.mag2() + thisMass * thisMass);
        direction += thisMomentum;
        HadronicEnergy += Energy;
      }
    }
    if (HadronicEnergy > 0.0) {
      direction = direction.unit();
      HadronicEnergy -= 938.92 * MeV;
      HadronicEnergy /= GeV;
      G4int NumOfMuonsFromHAVertex =
          aHAVertexMuons->GetNumberOfMuons(HadronicEnergy);
      // create the vertexes and add the muons
      for (G4int iadd = 0; iadd < NumOfMuonsFromHAVertex; iadd++) {
        aHAVertexMuons->ReadMuon();
        // first get the vertex from the class container
        G4ThreeVector aPosition = aHAVertexMuons->GetPosition();
        G4ThreeVector aMomentum = aHAVertexMuons->GetMomentum();
        t0 = aHAVertexMuons->GetTime();
        aPosition.rotateUz(direction);
        aMomentum.rotateUz(direction);
        idbeam = 13; // BUG ??? I have not keep the muon type. Choose in random
        if (G4UniformRand() > 0.5)
          idbeam = -13;
        xx0 = aPosition[0] + xneu;
        yy0 = aPosition[1] + yneu;
        zz0 = aPosition[2] + zneu;
        pxx0 = aMomentum[0];
        pyy0 = aMomentum[1];
        pzz0 = aMomentum[2];
        // define the particle object and properties from the particle PDG code
        // idbeam
        G4PrimaryParticle *initialParticle =
            new G4PrimaryParticle(idbeam, pxx0 * GeV, pyy0 * GeV, pzz0 * GeV);
        G4PrimaryVertex *vertex = new G4PrimaryVertex(
            G4ThreeVector(xx0 * cm, yy0 * cm, zz0 * cm), t0 * ns);
        vertex->SetPrimary(initialParticle);
        anEvent->AddPrimaryVertex(vertex);
      }
      G4cout << "Hadronic run. Event " << ievent << " with hadronic energy "
             << HadronicEnergy << " GeV" << G4endl;
      G4cout << "Number of Initial Particles " << numberofParticles
             << ". Number of aditional muons " << NumOfMuonsFromHAVertex
             << G4endl;
      // add the number of these muons to the numberofParticles
      numberofParticles += NumOfMuonsFromHAVertex;
    }
#endif
  }
#else
#ifdef G4MYHAMUONS_PARAMETERIZATION
  // Here we do parametrization for hadronic interactions (primary particles
  // that are considered are all except leptons, gamma and pion zero
  // input files must have been generated from dif_cross application with hadron
  // parametrization enabled
  // that means that in the secondaries there are no leptons, gammas and pion
  // zeros
  // the output is just the energetic muons (Ek>1GeV)
  else {
    position[0] = 0.0;
    position[1] = 0.0;
    position[2] = 0.0;
    t0 = 0.0; // starting particle time is common in neutrino interaction
    // Generate the Event (reads from Pythia output file)
    HEPEvt->GeneratePrimaryVertex(anEvent);
    // Change the position of the vertex of the event
    anEvent->GetPrimaryVertex(0)->SetPosition(0.0, 0.0, 0.0);
    numberofParticles = anEvent->GetPrimaryVertex(0)->GetNumberOfParticle();
    direction = G4ThreeVector(0.0, 0.0, 0.0);
    G4float HadronicEnergy = 0.0;
    for (G4int ipart = 0; ipart < numberofParticles; ipart++) {
      idbeam =
          fabs(anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetPDGcode());
      if (idbeam != 22 && idbeam != 13 && idbeam != 11 && idbeam != 15 &&
          idbeam != 111) { // disregard em particles
        G4ThreeVector thisMomentum =
            anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetMomentum();
        G4double thisMass =
            anEvent->GetPrimaryVertex(0)->GetPrimary(ipart)->GetMass();
        G4double Energy = sqrt(thisMomentum.mag2() + thisMass * thisMass);
        direction += thisMomentum;
        HadronicEnergy += (float)Energy;
      }
    }
    direction =
        direction.unit(); // this direction is used in the stacking action
    HadronicEnergy -= 938.92 * MeV;
    HadronicEnergy /= (float)GeV;
    outMuonHAFile->write((char *)&HadronicEnergy, sizeof(HadronicEnergy));
    G4cout << "Hadronic parametrization. Event " << ievent << " with energy "
           << HadronicEnergy << " GeV" << G4endl;
  }
#endif
#endif
#endif
#endif
  myTracking->numofInitialParticles = numberofParticles;
}
