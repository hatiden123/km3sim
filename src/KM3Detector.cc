//***** Generated by Geant4 Geometry Editor at  Thu Apr 04 19:40:34 GMT+03:00
//2002 *****

//------HeaderFile-
#include "KM3Detector.hh"

#include "G4UnitsTable.hh"

#include "G4VUserDetectorConstruction.hh"
#include "KM3SD.hh"
#include "KM3StackingAction.hh"
#include "KM3EMShowerModel.hh" //apostolis parametrization
KM3EMShowerModel *myEMShowerModel;

#ifdef G4HADRONIC_COMPILE
#include "KM3HAShowerModel.hh" //apostolis parametrization
KM3HAShowerModel *myHAShowerModel;
#endif

#include "globals.hh"
#include "G4Material.hh"
#include "G4MaterialTable.hh"
#include "G4Element.hh"
#include "G4ElementTable.hh"
#include "G4Box.hh"
#include "G4Sphere.hh"
#include "G4Tubs.hh"
#include "G4LogicalVolume.hh"
#include "G4ThreeVector.hh"
#include "G4PVPlacement.hh"
#include "G4PVReplica.hh"
#include "G4SDManager.hh"
#include "G4VisAttributes.hh"
#include "G4Colour.hh"
#include "G4UserLimits.hh"
#include "G4RegionStore.hh"

KM3Detector::KM3Detector() {
  allCathods = new KM3Cathods();
  allStoreys = new std::vector<StoreysPositions *>;
  allOMs = new std::vector<OMPositions *>;
}
KM3Detector::~KM3Detector() {
  // newgeant  sxp.Finalize();
  delete allCathods;

  for (size_t i = 0; i < allOMs->size(); i++) {
    (*allOMs)[i]->CathodsIDs->clear();
    delete (*allOMs)[i]->CathodsIDs;
    free((*allOMs)[i]);
  }
  allOMs->clear();
  delete allOMs;

  for (size_t i = 0; i < allStoreys->size(); i++) {
    (*allStoreys)[i]->BenthosIDs->clear();
    delete (*allStoreys)[i]->BenthosIDs;
    free((*allStoreys)[i]);
  }
  allStoreys->clear();
  delete allStoreys;


  delete myEMShowerModel;
#ifdef G4HADRONIC_COMPILE
  delete myHAShowerModel;
#endif
}


void KM3Detector::FindDetectorRadius() {
  double absdetectorRadius = 0.0;
  lowestStorey = 0.0;
  highestStorey = 0.0;
  outerStorey = 0.0;
  detectorMaxz = 0.0;
  detectorMaxRho = 0.0;
  detectorCenter = G4ThreeVector(0.0, 0.0, 0.0);
  for (size_t isto = 0; isto < allStoreys->size(); isto++) {
    G4ThreeVector pos = (*(allStoreys))[isto]->position;
    double radius = (*(allStoreys))[isto]->radius;
    double dist = pos.mag() + radius;
    if (absdetectorRadius < dist)
      absdetectorRadius = dist;
    if (pos[2] < lowestStorey)
      lowestStorey = pos[2];
    if (pos[2] > highestStorey)
      highestStorey = pos[2];
    double distRho = sqrt(pos[0] * pos[0] + pos[1] * pos[1]) + radius;
    if (outerStorey < distRho)
      outerStorey = distRho;
  }
  detectorMaxRho = outerStorey + MaxAbsDist;
  detectorRadius = MaxAbsDist + absdetectorRadius;
  bottomPosition += lowestStorey;
  detectorMaxz = highestStorey + MaxAbsDist;
  G4cout << "Detector radius (m) and bottom position (m) " << detectorRadius / m
         << " " << bottomPosition / m << G4endl;
  MyGenerator->PutFromDetector(detectorCenter, detectorMaxRho, detectorMaxz,
                               bottomPosition);
}

#include "CLHEP/Evaluator/Evaluator.h"

void KM3Detector::SetUpVariables() {
  FILE *infile;
  double MaxRelDist;
  NUMENTRIES = -10;
  NUMENTRIES_ANGLEACC = -10;

  if ((infile = fopen(Parameter_File, "r")) == NULL) {
    G4Exception("Error open input parameter file\n", "", FatalException, "");
  } else {
    char varname[50];
    char expression[50];
    int readvalues[18] = {18 * 0};
    std::string String0 = std::string("detectorDepth");
    std::string String1 = std::string("bottomPosition");
    std::string String2 = std::string("PPCKOV");
    std::string String3 = std::string("RINDEX_WATER");
    std::string String4 = std::string("ABSORPTION_WATER");
    std::string String5 = std::string("RINDEX_GLASS");
    std::string String6 = std::string("ABSORPTION_GLASS");
    std::string String7 = std::string("RINDEX_GELL");
    std::string String8 = std::string("ABSORPTION_GELL");
    std::string String9 = std::string("RINDEX_AIR");
    std::string String10 = std::string("ABSORPTION_AIR");
    std::string String11 = std::string("RINDEX_CATH");
    std::string String12 = std::string("ABSORPTION_CATH");
    std::string String13 = std::string("Q_EFF");
    std::string String14 = std::string("MIE_WATER");
    std::string String15 = std::string("MIE_MODEL");
    std::string String16 = std::string("COS_ANGLES");
    std::string String17 = std::string("ANG_ACCEPT");

    HepTool::Evaluator fCalc;
    fCalc.setSystemOfUnits(
        1.e+3, 1. / 1.60217733e-25, 1.e+9, 1. / 1.60217733e-10, 1.0, 1.0,
        1.0); // asign default variables to evaluator (Geant4 Units)
    while (fscanf(infile, "%s", varname) != EOF) {
      std::string thename = std::string(varname);
      if (thename == String0) {
        readvalues[0] = 1;
        fscanf(infile, "%s\n", expression);
        detectorDepth = fCalc.evaluate(expression);
      } // this should be the detector depth at the center of the detector. It
        // is used to calculate
      // the seawater density using the compressibility of the sea water (see
      // below)
      else if (thename == String1) {
        readvalues[1] = 1;
        fscanf(infile, "%s\n", expression);
        bottomPosition = fCalc.evaluate(expression);
      } // this is the position of the bottom of the sea relative to detector
        // center
      else if (thename == String2) {
        readvalues[2] = 1;
        fscanf(infile, "%s", expression);
        NUMENTRIES = (int)fCalc.evaluate(expression);
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          PPCKOV[i] = h_Planck * c_light / fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        PPCKOV[NUMENTRIES - 1] =
            h_Planck * c_light / fCalc.evaluate(expression);
      } else if (thename == String3) {
        readvalues[3] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          RINDEX_WATER[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        RINDEX_WATER[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String4) {
        readvalues[4] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        fscanf(infile, "%s", expression);
        Water_Transparency = fCalc.evaluate(expression);
        fscanf(infile, "%s", expression);
        MaxRelDist = fCalc.evaluate(expression); // How many absorption lengths
                                                 // optical photons can cross
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          ABSORPTION_WATER[i] = Water_Transparency / fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        ABSORPTION_WATER[NUMENTRIES - 1] =
            Water_Transparency / fCalc.evaluate(expression);
      } else if (thename == String5) {
        readvalues[5] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          RINDEX_GLASS[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        RINDEX_GLASS[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String6) {
        readvalues[6] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          ABSORPTION_GLASS[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        ABSORPTION_GLASS[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String7) {
        readvalues[7] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          RINDEX_GELL[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        RINDEX_GELL[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String8) {
        readvalues[8] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          ABSORPTION_GELL[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        ABSORPTION_GELL[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String9) {
        readvalues[9] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          RINDEX_AIR[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        RINDEX_AIR[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String10) {
        readvalues[10] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          ABSORPTION_AIR[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        ABSORPTION_AIR[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String11) {
        readvalues[11] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          RINDEX_CATH[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        RINDEX_CATH[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String12) {
        readvalues[12] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          ABSORPTION_CATH[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        ABSORPTION_CATH[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String13) {
        readvalues[13] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property (PPCKOV keyword)",
                      "", FatalException, "");
        fscanf(infile, "%s", expression);
        Quantum_Efficiency = fCalc.evaluate(
            expression); // maximum quantum efficienscy, used in KM3Cherenkov
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          Q_EFF[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        Q_EFF[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String14) {
        readvalues[14] = 1;
        if (NUMENTRIES < 0)
          G4Exception("Wavelengths of Optical Photons must be set before "
                      "setting any other Optical Property (PPCKOV keyword)",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES - 1; i++) {
          fscanf(infile, "%s", expression);
          SCATTER_WATER[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        SCATTER_WATER[NUMENTRIES - 1] = fCalc.evaluate(expression);
      } else if (thename == String15) {
        readvalues[15] = 1;
        fscanf(infile, "%s\n", expression);
        MieModel = fCalc.evaluate(expression);
      } // Mie model as of mie phase factors file
      else if (thename == String16) {
        readvalues[16] = 1;
        fscanf(infile, "%s", expression);
        NUMENTRIES_ANGLEACC = (int)fCalc.evaluate(expression);
        for (int i = 0; i < NUMENTRIES_ANGLEACC - 1; i++) {
          fscanf(infile, "%s", expression);
          COSANGLES[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        COSANGLES[NUMENTRIES_ANGLEACC - 1] = fCalc.evaluate(expression);
      } else if (thename = String17) {
        readvalues[17] = 1;
        if (NUMENTRIES_ANGLEACC < 0)
          G4Exception("Cosine angles values must be set before setting angular "
                      "acceptance values",
                      "", FatalException, "");
        for (int i = 0; i < NUMENTRIES_ANGLEACC - 1; i++) {
          fscanf(infile, "%s", expression);
          ACCEPTANCE[i] = fCalc.evaluate(expression);
        }
        fscanf(infile, "%s\n", expression);
        ACCEPTANCE[NUMENTRIES_ANGLEACC - 1] = fCalc.evaluate(expression);
      } else
        G4Exception("Not a keyword I can recognize\n", "", FatalException, "");
    }
    fclose(infile);
    for (int i = 0; i < 18; i++) {
      if (readvalues[i] == 0) {
        switch (i) {
        case 0:
          G4Exception("detectorDepth not set", "", FatalException, "");
          break;
        case 1:
          G4Exception("bottomPosition not set", "", FatalException, "");
          break;
        case 2:
          G4Exception("PPCKOV not set", "", FatalException, "");
          break;
        case 3:
          G4Exception("RINDEX_WATER not set", "", FatalException, "");
          break;
        case 4:
          G4Exception("ABSORPTION_WATER not set", "", FatalException, "");
          break;
        case 5:
          G4Exception("RINDEX_GLASS not set", "", FatalException, "");
          break;
        case 6:
          G4Exception("ABSORPTION_GLASS not set", "", FatalException, "");
          break;
        case 7:
          G4Exception("RINDEX_GELL not set", "", FatalException, "");
          break;
        case 8:
          G4Exception("ABSORPTION_GELL not set", "", FatalException, "");
          break;
        case 9:
          G4Exception("RINDEX_AIR not set", "", FatalException, "");
          break;
        case 10:
          G4Exception("ABSORPTION_AIR not set", "", FatalException, "");
          break;
        case 11:
          G4Exception("RINDEX_CATH not set", "", FatalException, "");
          break;
        case 12:
          G4Exception("ABSORPTION_CATH not set", "", FatalException, "");
          break;
        case 13:
          G4Exception("Q_EFF not set", "", FatalException, "");
          break;
        case 14:
          G4Exception("MIE_WATER not set", "", FatalException, "");
          break;
        case 15:
          G4Exception("MIE_MODEL not set", "", FatalException, "");
          break;
        case 16:
          G4Exception("COS_ANGLES not set", "", FatalException, "");
          break;
        case 17:
          G4Exception("ANG_ACCEPT not set", "", FatalException, "");
          break;
        }
      }
    }
  }
  MaxAbsDist = MaxRelDist * Water_Transparency;
}

////////// Construction of
///Materials//////////////////////////////////////////////////////////////////////
void KM3Detector::ConstructMaterials() {
  // All Basic Elements
  // --------------------------------------------------------------------------
  double weightH = 1.007940 * g / mole;
  double weightO = 15.999400 * g / mole;
  double weightCl = 35.453000 * g / mole;
  double weightMg = 24.305000 * g / mole;
  double weightNa = 22.989770 * g / mole;
  double weightSi = 28.085500 * g / mole;
  double weightB = 10.811000 * g / mole;
  double weightAl = 26.981538 * g / mole;
  double weightC = 12.010700 * g / mole;
  double weightN = 14.006700 * g / mole;
  double weightCa = 40.078000 * g / mole;
  double weightK = 39.098300 * g / mole;
  double weightS = 32.065000 * g / mole;
  double weightFe = 55.845000 * g / mole;
  G4Element *elementH = new G4Element("Hydrogen", "H", 1., weightH);
  G4Element *elementO = new G4Element("Oxygen", "O", 8., weightO);
  G4Element *elementCl = new G4Element("Chlorine", "Cl", 17., weightCl);
  G4Element *elementMg = new G4Element("Magnisium", "Mg", 12., weightMg);
  G4Element *elementNa = new G4Element("Sodium", "Na", 11., weightNa);
  G4Element *elementSi = new G4Element("Silicon", "Si", 14., weightSi);
  G4Element *elementB = new G4Element("Boron", "B", 5., weightB);
  G4Element *elementAl = new G4Element("Aluminium", "Al", 13., weightAl);
  G4Element *elementC = new G4Element("Carbon", "C", 6., weightC);
  G4Element *elementN = new G4Element("Nitrogen", "N", 7., weightN);
  G4Element *elementCa = new G4Element("Calcium", "Ca", 20., weightCa);
  G4Element *elementK = new G4Element("Potassium", "K", 19., weightK);
  G4Element *elementS = new G4Element("Sulphur", "S", 16., weightS);
  G4Element *elementFe = new G4Element("Iron", "Fe", 26., weightFe);

  // Earths Crust
  G4Material *Crust = new G4Material("Crust", 2.6 * g / cm3, 8, kStateSolid,
                                     287.15 * kelvin, 1.0 * atmosphere);
  Crust->AddElement(elementO, 0.481);
  Crust->AddElement(elementSi, 0.277);
  Crust->AddElement(elementAl, 0.081);
  Crust->AddElement(elementFe, 0.050);
  Crust->AddElement(elementCa, 0.036);
  Crust->AddElement(elementNa, 0.028);
  Crust->AddElement(elementK, 0.026);
  Crust->AddElement(elementMg, 0.021);

  // WATER---here is added the depedence of the salinity and density on the
  // depth (UNESCO)--
  // At the surface the seawater density is approximately 1.029gr/cm3
  // (E.G.Anassontzis, "The NESTOR Site",
  // Proceedings of the 3rd NESTOR International Workshop, October 19-21, 1993,
  // Pylos Greece, pp614-630)
  // based on the composition of ocean seawater for 35o/oo
  // www.soest.hawaii.edu/oceanography we have
  double abundanceNa = 469.0e-3 * mole / kg;
  double abundanceMg = 52.8e-3 * mole / kg;
  double abundanceCa = 10.3e-3 * mole / kg;
  double abundanceK = 10.2e-3 * mole / kg;
  double abundanceCl = 545.9e-3 * mole / kg;
  double abundanceSO4 = 28.2e-3 * mole / kg;
  double abundanceHCO3 = 2.33e-3 * mole / kg;
  // The Mediterranean Salinity is about 40o/oo (gr/kgr of seawater)
  // we scale these abundances for 40o/oo salinity
  double scale = 40.0 / 35.0;
  abundanceNa *= scale;
  abundanceMg *= scale;
  abundanceCa *= scale;
  abundanceK *= scale;
  abundanceCl *= scale;
  abundanceSO4 *= scale;
  abundanceHCO3 *= scale;
  // we convert to gr/kgr of the solution (seawater) for each element or
  // composite
  abundanceNa *= weightNa;
  abundanceMg *= weightMg;
  abundanceCa *= weightCa;
  abundanceK *= weightK;
  abundanceCl *= weightCl;
  abundanceSO4 *= (weightS + 4 * weightO);
  abundanceHCO3 *= (weightH + weightC + 3 * weightO);
  double abundanceH2O =
      1.0 - (abundanceNa + abundanceMg + abundanceCa + abundanceK +
             abundanceCl + abundanceSO4 + abundanceHCO3);
  //------------------the composites of sea
  //water------------------------------------
  // if the material is not used to fill a specific logical volume the density
  // is not used
  G4Material *H2O = new G4Material("H2O", 1.0 * g / cm3, 2);
  H2O->AddElement(elementH, 2);
  H2O->AddElement(elementO, 1);
  G4Material *SO4 = new G4Material("SO4", 1.0 * g / cm3, 2);
  SO4->AddElement(elementS, 1);
  SO4->AddElement(elementO, 4);
  G4Material *HCO3 = new G4Material("HCO3", 1.0 * g / cm3, 3);
  HCO3->AddElement(elementH, 1);
  HCO3->AddElement(elementC, 1);
  HCO3->AddElement(elementO, 3);
  // calculate the density of sea water using the compressibility (Apostolis
  // Thesis appendix C)
  // and the detector depth (in meters : not water equivalent)
  double Compressibility = 4.29e-5 / bar;
  double gravity = 9.8 * m / (s * s);
  double surfaceDensity = 1.029 * g / cm3;
  double seawaterDensity =
      surfaceDensity *
      exp(gravity * surfaceDensity * Compressibility * detectorDepth);
  //-----------------------------------------------------------------
  G4Material *Water = new G4Material("Water", seawaterDensity, 8, kStateLiquid,
                                     287.15 * kelvin, 1.0 * atmosphere);
  Water->AddMaterial(H2O, abundanceH2O);
  Water->AddMaterial(SO4, abundanceSO4);
  Water->AddMaterial(HCO3, abundanceHCO3);
  Water->AddElement(elementCl, abundanceCl);
  Water->AddElement(elementMg, abundanceMg);
  Water->AddElement(elementNa, abundanceNa);
  Water->AddElement(elementCa, abundanceCa);
  Water->AddElement(elementK, abundanceK);

  // GLASS and GELL change (27/5/2005) of the composition of borosilicate glass
  // according to
  // US Standards (http://www.udel.edu/chem/GlassShop/PhysicalProperties.htm)
  // 80.6% SiO2, 13.0% B2O3, 4.0% Na2O, 2.4% Al2O3
  G4Material *materialSiO2 = new G4Material("SiO2", 1.0 * g / cm3, 2);
  materialSiO2->AddElement(elementSi, 1);
  materialSiO2->AddElement(elementO, 2);
  G4Material *materialB2O3 = new G4Material("B2O3", 1.0 * g / cm3, 2);
  materialB2O3->AddElement(elementB, 2);
  materialB2O3->AddElement(elementO, 3);
  G4Material *materialNa2O = new G4Material("Na2O", 1.0 * g / cm3, 2);
  materialNa2O->AddElement(elementNa, 2);
  materialNa2O->AddElement(elementO, 1);
  G4Material *materialAl2O3 = new G4Material("Al2O3", 1.0 * g / cm3, 2);
  materialAl2O3->AddElement(elementAl, 2);
  materialAl2O3->AddElement(elementO, 3);
  G4Material *Glass = new G4Material("Glass", 2.23 * g / cm3, 4, kStateSolid,
                                     287.15 * kelvin, 1.0 * atmosphere);
  Glass->AddMaterial(materialSiO2, 0.806);
  Glass->AddMaterial(materialB2O3, 0.130);
  Glass->AddMaterial(materialNa2O, 0.040);
  Glass->AddMaterial(materialAl2O3, 0.024);

  // Silicone Gel Material.
  // density is 0.97g/cm3
  // (http://www.wackersilicones.com/documents/techdatasheets/silgel612.pdf)
  // Polydimethylsiloxane polymeres -- (C2H6OSi)n
  G4Material *Gell = new G4Material("Gell", 0.97 * g / cm3, 4, kStateSolid,
                                    287.15 * kelvin, 1.0 * atmosphere);
  Gell->AddElement(elementC, 2);
  Gell->AddElement(elementH, 6);
  Gell->AddElement(elementO, 1);
  Gell->AddElement(elementSi, 1);

  // AIR
  // -----------------------------------------------------------------------------
  G4Material *Air = new G4Material("Air", 1.29e-03 * g / cm3, 2);
  Air->AddElement(elementN, .7);
  Air->AddElement(elementO, .3);

  // CATHOD
  // -------------------------------------------------------------------------------
  G4Material *Cathod =
      new G4Material("Cathod", 22, 47.867 * g / mole, 4.507 * g / cm3,
                     kStateSolid, 287.15 * kelvin, 1.0 * atmosphere);

  // G4cout<<*(G4Material::GetMaterialTable())<<G4endl;

  // ------------------------------------------------------------------------------------------------
  // Set OPTICAL PROPERTIES (read from file) of materials
  // ////////////////////////////////////////////////////////////////

  // WATER
  G4MaterialPropertiesTable *Properties_Water = new G4MaterialPropertiesTable();
  Properties_Water->AddProperty("RINDEX", PPCKOV, RINDEX_WATER, NUMENTRIES);
  Properties_Water->AddProperty("ABSLENGTH", PPCKOV, ABSORPTION_WATER,
                                NUMENTRIES);
  Properties_Water->AddProperty("MIELENGTH", PPCKOV, SCATTER_WATER, NUMENTRIES);
  Properties_Water->AddConstProperty("MIEPHASE", MieModel);
  Water->SetMaterialPropertiesTable(Properties_Water);

  // GLASS    -----------------------------------------------------------
  G4MaterialPropertiesTable *Properties_Glass = new G4MaterialPropertiesTable();
  Properties_Glass->AddProperty("ABSLENGTH", PPCKOV, ABSORPTION_GLASS,
                                NUMENTRIES);
  Properties_Glass->AddProperty("RINDEX", PPCKOV, RINDEX_GLASS, NUMENTRIES);
  Glass->SetMaterialPropertiesTable(Properties_Glass);

  // GELL      -----------------------------------------------------------
  G4MaterialPropertiesTable *Properties_Gell = new G4MaterialPropertiesTable();
  Properties_Gell->AddProperty("ABSLENGTH", PPCKOV, ABSORPTION_GELL,
                               NUMENTRIES);
  Properties_Gell->AddProperty("RINDEX", PPCKOV, RINDEX_GELL, NUMENTRIES);
  Gell->SetMaterialPropertiesTable(Properties_Gell);

  // AIR       -----------------------------------------------------------
  // absorption length of air set to 1 meter to prevent trapping of a photon
  // inside air material
  G4MaterialPropertiesTable *Properties_Air = new G4MaterialPropertiesTable();
  Properties_Air->AddProperty("ABSLENGTH", PPCKOV, ABSORPTION_AIR, NUMENTRIES);
  Properties_Air->AddProperty("RINDEX", PPCKOV, RINDEX_AIR, NUMENTRIES);
  Air->SetMaterialPropertiesTable(Properties_Air);

  // CATHOD       ----------------------------------------------------------
  G4MaterialPropertiesTable *Properties_Cath = new G4MaterialPropertiesTable();
  Properties_Cath->AddProperty("ABSLENGTH", PPCKOV, ABSORPTION_CATH,
                               NUMENTRIES);
  Properties_Cath->AddProperty("RINDEX", PPCKOV, RINDEX_CATH, NUMENTRIES);
  Properties_Cath->AddProperty("Q_EFF", PPCKOV, Q_EFF, NUMENTRIES);
  Properties_Cath->AddProperty("ANGULAR_ACCEPTANCE", COSANGLES, ACCEPTANCE,
                               NUMENTRIES_ANGLEACC);
  Cathod->SetMaterialPropertiesTable(Properties_Cath);
}

#include "G4VoxelLimits.hh"

int KM3Detector::TotalPMTEntities(const G4VPhysicalVolume *aPVolume) const {
  static int Cathods = 0;
  static int Storeys = 0;
  static int OMs = 0;
  static G4AffineTransform AffineTrans;
  static G4RotationMatrix RotationMatr;
  static int Depth = 0;
  static int Hist[20];
  static std::vector<int>
      *aBenthosIDs; // static in order to load the benthos (OMs)
  static std::vector<int>
      *aCathodsIDs; // static in order to load the cathods (Cathods)

  //  G4cout <<Depth<<" "<<aPVolume->GetCopyNo()<<"
  //  "<<aPVolume->GetName()<<G4endl; //tempotest
  Hist[Depth] = aPVolume->GetCopyNo();
  Depth++;
  RotationMatr = RotationMatr * aPVolume->GetObjectRotationValue();
  //  if(aPVolume->GetName() == "CathodVolume_PV"){ //for newgeant  add "_PV" at
  //  the end of physical volume name
  if ((aPVolume->GetName()).contains("CathodVolume")) { // for newgeant  add
                                                        // "_PV" at the end of
                                                        // physical volume name
    G4ThreeVector Position =
        AffineTrans.TransformPoint(aPVolume->GetObjectTranslation());
    G4ThreeVector Direction = RotationMatr(G4ThreeVector(0.0, 0.0, 1.0));
    G4Transform3D trans(RotationMatr, Position);
    // estimate cathod radius///////////////////////////////
    double CathodRadius = 0.0;
    double CathodHeight = -1.0 * mm; // set default to begative, since it is
                                       // not applicable to spherical cathods
    if (aPVolume->GetLogicalVolume()->GetSolid()->GetEntityType() ==
        std::string("G4Sphere")) {
      CathodRadius = ((G4Sphere *)aPVolume->GetLogicalVolume()->GetSolid())
                         ->GetOuterRadius();
      double InnerRadius =
          ((G4Sphere *)aPVolume->GetLogicalVolume()->GetSolid())
              ->GetInnerRadius();
      if ((CathodRadius - InnerRadius) < 1.001 * mm)
        CathodRadius =
            0.5 * (CathodRadius +
                   InnerRadius); // applicable mainly to shell type cathods (EM)
    } else if (aPVolume->GetLogicalVolume()->GetSolid()->GetEntityType() ==
               std::string("G4Tubs")) {
      CathodRadius = ((G4Tubs *)aPVolume->GetLogicalVolume()->GetSolid())
                         ->GetOuterRadius(); // applicable to thin tube cathods
                                             // (normal run)
      CathodHeight = ((G4Tubs *)aPVolume->GetLogicalVolume()->GetSolid())
                         ->GetZHalfLength();
      CathodHeight *= 2.0; // full height
    }
    ///////////////////////////////////////////
    allCathods->addCathod(trans, Position, Direction, CathodRadius,
                          CathodHeight, Depth - 1);
    for (int i = 1; i < Depth; i++)
      allCathods->addToTree(Hist[i]);
    // G4cout << Depth <<" "<<Hist[0]<<" "<<Hist[1]<<" "<<Hist[2]<<"
    // "<<Hist[3]<<" "<<Hist[4]<<" "<<Hist[5]<<G4endl; //tempotest
    // G4cout << Position <<" "<<Direction<<G4endl; //tempotest
    aCathodsIDs->push_back(Cathods);
    Cathods++;
  } else {
    if ((aPVolume->GetName()).contains("OMVolume")) { // for newgeant  add "_PV"
                                                      // at the end of physical
                                                      // volume name
      OMPositions *aOM = (OMPositions *)malloc(sizeof(OMPositions));
      aOM->position =
          AffineTrans.TransformPoint(aPVolume->GetObjectTranslation());
      aCathodsIDs = new std::vector<int>;
      aOM->CathodsIDs = aCathodsIDs;
      // if OM is sphere then set the outer radius as radius,
      // if it is tubs then set the proper radius
      // else set the geometrical sum of the extend on the three axis
      //(maximum extend. Exact only for Boxes)
      if (aPVolume->GetLogicalVolume()->GetSolid()->GetEntityType() ==
          std::string("G4Sphere")) {
        aOM->radius = ((G4Sphere *)aPVolume->GetLogicalVolume()->GetSolid())
                          ->GetOuterRadius();
      } else if (aPVolume->GetLogicalVolume()->GetSolid()->GetEntityType() ==
                 std::string("G4Tubs")) {
        double zLength = ((G4Tubs *)aPVolume->GetLogicalVolume()->GetSolid())
                               ->GetZHalfLength();
        double oRadius = ((G4Tubs *)aPVolume->GetLogicalVolume()->GetSolid())
                               ->GetOuterRadius();
        aOM->radius = sqrt(zLength * zLength + oRadius * oRadius);
      } else {
        G4VoxelLimits voxelLimits; // Defaults to "infinite" limits.
        G4AffineTransform affineTransform; // no transform
        double xmin, xmax, ymin, ymax, zmin, zmax;
        aPVolume->GetLogicalVolume()->GetSolid()->CalculateExtent(
            kXAxis, voxelLimits, affineTransform, xmin, xmax);
        aPVolume->GetLogicalVolume()->GetSolid()->CalculateExtent(
            kYAxis, voxelLimits, affineTransform, ymin, ymax);
        aPVolume->GetLogicalVolume()->GetSolid()->CalculateExtent(
            kZAxis, voxelLimits, affineTransform, zmin, zmax);
        xmax = fmax(fabs(xmax), fabs(xmin));
        ymax = fmax(fabs(ymax), fabs(ymin));
        zmax = fmax(fabs(zmax), fabs(zmin));
        aOM->radius = sqrt(xmax * xmax + ymax * ymax + zmax * zmax);
      }
      allOMs->push_back(aOM);
      aBenthosIDs->push_back(OMs);
      OMs++;
    }
    if ((aPVolume->GetName())
            .contains("StoreyVolume")) { // for newgeant  add "_PV" at the end
                                         // of physical volume name
      StoreysPositions *aStorey =
          (StoreysPositions *)malloc(sizeof(StoreysPositions));
      aStorey->position =
          AffineTrans.TransformPoint(aPVolume->GetObjectTranslation());
      aBenthosIDs = new std::vector<int>;
      aStorey->BenthosIDs = aBenthosIDs;
      allStoreys->push_back(aStorey);
      Storeys++;
    }
    G4AffineTransform tempoaffine(aPVolume->GetObjectRotationValue().inverse(),
                                  aPVolume->GetObjectTranslation());
    AffineTrans = tempoaffine * AffineTrans;
    for (int i = 0; i < aPVolume->GetLogicalVolume()->GetNoDaughters(); i++) {
      // the following is to fix new GDML that does not apply a copyNumber to
      // physical volumes
      aPVolume->GetLogicalVolume()->GetDaughter(i)->SetCopyNo(i);
      TotalPMTEntities(aPVolume->GetLogicalVolume()->GetDaughter(i));
    }
    AffineTrans = tempoaffine.Inverse() * AffineTrans;
  }
  RotationMatr = RotationMatr * aPVolume->GetObjectRotationValue().inverse();
  Depth--;
  return Cathods;
}

// newgeant #include "G4Processor/GDMLProcessor.h"
#include "G4GDMLParser.hh" //newgeant
#include "G4LogicalVolumeStore.hh"
#include "G4PhysicalVolumeStore.hh"
#include "G4GeometryManager.hh"

G4VPhysicalVolume *KM3Detector::Construct() {
  SetUpVariables();
  ConstructMaterials();
  G4GeometryManager::GetInstance()->SetWorldMaximumExtent(1000.0 * m);
  // newgeant  sxpInitialize();
  // newgeant  sxp.Run();

  // newgeant fWorld =  (G4VPhysicalVolume
  // *)GDMLProcessor::GetInstance()->GetWorldVolume();
  G4GDMLParser parser; // newgeant
  parser.Read(Geometry_File); // newgeant
  fWorld = (G4VPhysicalVolume *)parser.GetWorldVolume(); // newgeant
  if (fWorld == 0)
    G4Exception("World volume not set properly check your setup selection "
                "criteria or GDML input!",
                "", FatalException, "");

  G4cout << "Total Cathods " << TotalPMTEntities(fWorld) << G4endl;

  //  int History[10]={20,20,18,0,2,0,0,0,0,0};
  //  int dep=5;
  //  G4cout <<"123456 "<<allCathods->GetCathodId(dep,History)<<G4endl;
  //  History[3]=1;
  //  G4cout <<"123456 "<<allCathods->GetCathodId(dep,History)<<G4endl;

  //------------------------------------------------
  // Sensitive detectors
  //------------------------------------------------

  G4SDManager *SDman = G4SDManager::GetSDMpointer();
  std::string MySDname = "mydetector1/MySD";
  KM3SD *aMySD = new KM3SD(MySDname);
  aMySD->SetVerboseLevel(1);
  aMySD->myStDetector = this;
  SDman->AddNewDetector(aMySD);

  // next find the Cathod && Dead logical volumes and assign them the sensitive
  // detectors
  G4LogicalVolume *aLogicalVolume;
  std::vector<G4LogicalVolume *> *aLogicalStore;
  std::string aString1("CathodVolume");
  std::string aString2("DeadVolume");
  size_t theSize = G4LogicalVolumeStore::GetInstance()->size();
  aLogicalStore = G4LogicalVolumeStore::GetInstance();
  if (DrawDetector) {
    G4cout << "choose colours for each detector component " << G4endl;
    G4cout << "Available colors are: white gray(grey) black red green blue "
              "cyan magenta yellow none"
           << G4endl;
  }
  for (size_t i = 0; i < theSize; i++) {
    aLogicalVolume = (*aLogicalStore)[i];

    //////////////////setup vrml visibility///////////////
    if (DrawDetector) {
      char Colour[10];
      G4cout << aLogicalVolume->GetName() << G4endl;
      G4cout << "Enter Color" << G4endl;
      scanf("%s", Colour);
      std::string colour(Colour);
      if (colour == std::string("none"))
        aLogicalVolume->SetVisAttributes(G4VisAttributes::Invisible);
      else {
        G4VisAttributes *MyVis;
        bool ok = true;
        if (colour == std::string("white"))
          MyVis = new G4VisAttributes(G4Colour::White());
        else if (colour == std::string("gray") || colour == std::string("grey"))
          MyVis = new G4VisAttributes(G4Colour::Gray());
        else if (colour == std::string("black"))
          MyVis = new G4VisAttributes(G4Colour::Black());
        else if (colour == std::string("red"))
          MyVis = new G4VisAttributes(G4Colour::Red());
        else if (colour == std::string("green"))
          MyVis = new G4VisAttributes(G4Colour::Green());
        else if (colour == std::string("blue"))
          MyVis = new G4VisAttributes(G4Colour::Blue());
        else if (colour == std::string("cyan"))
          MyVis = new G4VisAttributes(G4Colour::Cyan());
        else if (colour == std::string("magenta"))
          MyVis = new G4VisAttributes(G4Colour::Magenta());
        else if (colour == std::string("yellow"))
          MyVis = new G4VisAttributes(G4Colour::Yellow());
        else
          ok = false;
        if (ok) {
          MyVis->SetVisibility(true);
          MyVis->SetLineStyle(MyVis->unbroken);
          MyVis->SetLineWidth(1.);
          // MyVis->SetForceWireFrame(true);
          MyVis->SetForceSolid(true);
          aLogicalVolume->SetVisAttributes(MyVis);
        } else
          aLogicalVolume->SetVisAttributes(G4VisAttributes::Invisible);
      }
    }

    ////////////////////////////////////////////////////
    //    if( (aLogicalVolume->GetName() == aString1) ||
    //    (aLogicalVolume->GetName() == aString2) ){
    if (((aLogicalVolume->GetName()).contains(aString1)) ||
        ((aLogicalVolume->GetName()).contains(aString2))) {
      aLogicalVolume->SetSensitiveDetector(aMySD);
    }
  }

  // tempotest
  // G4VPhysicalVolume* aPhysicalVolume;
  // std::vector<G4VPhysicalVolume*> *aPhysicalStore;
  // theSize=G4PhysicalVolumeStore::GetInstance()->size();
  // aPhysicalStore = G4PhysicalVolumeStore::GetInstance();
  // for(size_t i=0 ; i<theSize ; i++){
  //   aPhysicalVolume = (*aPhysicalStore)[i];
  //   G4cout <<  aPhysicalVolume->GetName() <<"
  //   "<<aPhysicalVolume->GetMultiplicity()<<"
  //   "<<aPhysicalVolume->GetCopyNo()<< G4endl;
  // }
  // tempotest

  // fully adjustable benthos and storey linked list
  G4cout << "Total World Volume Entities= "
         << fWorld->GetLogicalVolume()->TotalVolumeEntities() << G4endl;

  // Next find from OM positions and radius in each store the storey radius
  for (size_t istorey = 0; istorey < allStoreys->size(); istorey++) {
    G4ThreeVector storeyposition = (*allStoreys)[istorey]->position;
    double MAXdist = 0.0;
    size_t OMnumber = (*allStoreys)[istorey]->BenthosIDs->size();
    for (size_t iom = 0; iom < OMnumber; iom++) {
      int iOM = (*((*allStoreys)[istorey]->BenthosIDs))[iom];
      G4ThreeVector OMposition = (*allOMs)[iOM]->position;
      double OMradius = (*allOMs)[iOM]->radius;
      double dist = (storeyposition - OMposition).mag() + OMradius;
      if (dist > MAXdist)
        MAXdist = dist;
    }
    (*allStoreys)[istorey]->radius = MAXdist;
  }

  // find detector radius and detector center from the Storeys
  FindDetectorRadius();

  //--------Write the header of the outfile and the Cathods Position, Direction
  //and History Tree
  int nnn0 = 0;
  int nnn1 = 1;
  int nben = allCathods->GetNumberOfCathods();

  if (outfile == NULL)
    G4cout << "ERROR OUTFILE\n" << G4endl;

#ifdef G4PRINT_HEADER
  fprintf(outfile, "%d %d %d %d %d %d %d %d %d %d %f %f %d %d\n", nnn0, nnn1,
          nnn1, nnn1, nben, nnn0, nnn0, nnn0, nnn0, nnn0, Water_Transparency,
          Quantum_Efficiency, nnn0, nnn0);
  allCathods->PrintAllCathods(outfile);
#endif

#if !defined(G4ENABLE_MIE) ||                                                  \
    (defined(G4ENABLE_MIE) && !defined(G4DISABLE_PARAMETRIZATION)) // newmie
  // initialize the splitted spheres
  initializeSpheres();
#endif

  // find the total photocathod area on a OM
  int CaPerOM = (*allOMs)[0]->CathodsIDs->size();
  TotCathodArea =
      CaPerOM * pi * allCathods->GetCathodRadius(0) *
      allCathods->GetCathodRadius(0); // this is valid only if at simulation
                                      // level (not EM or HA param) all cathods
                                      // have the same radius. Easy to change to
                                      // account for a detector with varius
                                      // cathod types

  //-----------apostolis Parameterisation ------------------------------
  G4Region *defRegion =
      G4RegionStore::GetInstance()->GetRegion("DefaultRegionForTheWorld");
  myEMShowerModel = new KM3EMShowerModel("emShowerModel", defRegion);
  myEMShowerModel->myStDetector = this;
  // TODO:
  // Why the hell do these lines even exist? EM/HA parametrization
  // has been commented out for the last 3 version, including this one.
  // Probably an `#ifdef HA_PARAM` or something is missing here.
  // TO_DELETE
  myEMShowerModel->InitializeFlux(EMParametrization_FILE, Quantum_Efficiency,
                                  TotCathodArea);
  myEMShowerModel->aMySD = aMySD;

#ifdef G4HADRONIC_COMPILE
  myHAShowerModel = new KM3HAShowerModel("haShowerModel", defRegion);
  myHAShowerModel->myStDetector = this;
  myHAShowerModel->InitializeFlux(HAParametrization_FILE, Quantum_Efficiency,
                                  TotCathodArea);
  myHAShowerModel->aMySD = aMySD;
#endif

  // return the physical World
  return fWorld;
}

#if !defined(G4ENABLE_MIE) ||                                                  \
    (defined(G4ENABLE_MIE) && !defined(G4DISABLE_PARAMETRIZATION)) // newmie
//--new initialize spheres
void KM3Detector::initializeSpheres(void) {
  // allmyBenthos keep for each sphere the positions and radii of the PMts that
  // are in the current spheres
  // first load in allmyBenthos the whole of the detector
  std::vector<StoreysPositions *> *allmyStoreys = allStoreys;
  howmanySpheres = 0;
  Spheres *mySphere = (Spheres *)malloc(sizeof(Spheres));
  splitSpheresCluster(allmyStoreys, mySphere);
  allSpheres = mySphere;
}

// split spheres with clustering methods.
void KM3Detector::splitSpheresCluster(
    std::vector<StoreysPositions *> *allmyStoreys, Spheres *mySphere) {
  static int depth = 0;
  G4cout << "Depth in split " << depth << G4endl;
  depth++;
  // find the center of mass of the detector
  G4ThreeVector center(0.0, 0.0, 0.0);
  int howmanyStoreys = allmyStoreys->size();
  for (int isto = 0; isto < howmanyStoreys; isto++) {
    center += (*allmyStoreys)[isto]->position;
  }
  center /= double(howmanyStoreys);

  // find the maximum distance
  double maxDistance = -1.0;
  for (int isto = 0; isto < howmanyStoreys; isto++) {
    G4ThreeVector pos = (*allmyStoreys)[isto]->position - center;
    double distance = pos.mag() + (*allmyStoreys)[isto]->radius;
    if (distance > maxDistance) {
      maxDistance = distance;
    }
  }

  // load the new sphere on array
  mySphere->center = center;
  mySphere->radius = maxDistance;
  howmanySpheres++;
  //  G4cout <<howmanySpheres <<" Number of benthos " << howmanyStoreys
  //  <<G4endl;
  std::vector<Spheres *> *thenext = new std::vector<Spheres *>;
  mySphere->allnext = thenext;
  if (howmanyStoreys == 1) {
    size_t OMnumber = (*allmyStoreys)[0]->BenthosIDs->size();
    for (size_t iom = 0; iom < OMnumber; iom++) {
      Spheres *mySpherenext = (Spheres *)malloc(sizeof(Spheres));
      int iOM = (*((*allmyStoreys)[0]->BenthosIDs))[iom];
      mySpherenext->center = (*allOMs)[iOM]->position;
      mySpherenext->radius = (*allOMs)[iOM]->radius;
      std::vector<Spheres *> *thenextnext = new std::vector<Spheres *>;
      mySpherenext->allnext = thenextnext;
      mySphere->allnext->push_back(mySpherenext);
    }
    return; // this is the end of the line
  }

  // load all benthos indexing in array ALLSTOREYS[1000] (needed only for
  // clustering)
  for (int isto = 0; isto < howmanyStoreys; isto++) {
    ALLSTOREYS[isto] = -1;
  }
  //----here is the implementation of the clustering
  // first time choose randomly the centers inside the initial sphere
  double centers[4][3];
  int imanystoreysarr[4];
  int numofCenters = 2;
  double radiusRANDOM, thetaRANDOM, phiRANDOM;
  for (int i = 0; i < numofCenters; i++) {
    radiusRANDOM = maxDistance * pow(drand48(), 0.33333333333);
    thetaRANDOM = M_PI * drand48();
    phiRANDOM = 2 * M_PI * drand48();
    centers[i][0] =
        center[0] + radiusRANDOM * sin(thetaRANDOM) * cos(phiRANDOM);
    centers[i][1] =
        center[1] + radiusRANDOM * sin(thetaRANDOM) * sin(phiRANDOM);
    centers[i][2] = center[2] + radiusRANDOM * cos(thetaRANDOM);
  }

  // next find the minimum and maximum number of storeys in each subdetector
  int nmove = 10;
  int jmin;
  double distm, dist;
  int imanymin, imanymax, igood;
  int imanyminMAX = -10;
  if (div(howmanyStoreys, 2).rem == 0) {
    imanymin = howmanyStoreys / 2;
    imanymax = howmanyStoreys - imanymin;
  } else {
    imanymin = (howmanyStoreys - 1) / 2;
    imanymax = howmanyStoreys - imanymin;
  }
  int iter = 0;
  while (nmove > 0) { // while the iteration process has not converged to an
                      // acceptable solution
    nmove = 0;
    for (int i = 0; i < howmanyStoreys;
         i++) { // find each storey to what center belongs (is closer)
      G4ThreeVector StoPos = (*allmyStoreys)[i]->position;
      distm = 1.0e20;
      for (int j = 0; j < numofCenters; j++) {
        dist = (centers[j][0] - StoPos[0]) * (centers[j][0] - StoPos[0]) +
               (centers[j][1] - StoPos[1]) * (centers[j][1] - StoPos[1]) +
               (centers[j][2] - StoPos[2]) * (centers[j][2] - StoPos[2]);
        if (dist < distm) {
          distm = dist;
          jmin = j;
        }
      }
      if (ALLSTOREYS[i] != jmin) {
        ALLSTOREYS[i] = jmin;
        nmove++;
      }
    }

    igood = 1;
    if (nmove == 0) { // if it has converged see if the solution is acceptable
      for (int j = 0; j < numofCenters; j++) {
        imanystoreysarr[j] = 0;
        for (int i = 0; i < howmanyStoreys; i++)
          if (ALLSTOREYS[i] == j)
            imanystoreysarr[j]++;
      }
      for (int j = 0; j < numofCenters; j++) {
        if ((imanystoreysarr[j] < imanymin) || (imanystoreysarr[j] > imanymax))
          igood = 0;
      }
      if (igood ==
          0) { // if it is not acceptable then find randomly other centers
        iter++;
        imanyminMAX = int(fmax(double(imanyminMAX),
                               fmin(imanystoreysarr[0],
                                    imanystoreysarr[1]))); // for only 2 centers
        if (iter > 1000) {
          imanymin = imanyminMAX;
          imanymax = howmanyStoreys - imanymin;
        }
        for (int j = 0; j < numofCenters; j++) {
          radiusRANDOM = maxDistance * pow(drand48(), 0.33333333333);
          thetaRANDOM = M_PI * drand48();
          phiRANDOM = 2 * M_PI * drand48();
          centers[j][0] =
              center[0] + radiusRANDOM * sin(thetaRANDOM) * cos(phiRANDOM);
          centers[j][1] =
              center[1] + radiusRANDOM * sin(thetaRANDOM) * sin(phiRANDOM);
          centers[j][2] = center[2] + radiusRANDOM * cos(thetaRANDOM);
        }
      }
    }

    if (igood == 1) { // if the solution is acceptable or it has not converged
      if (nmove != 0) { // if it has not converged
        // find the new center coordinates
        for (int j = 0; j < numofCenters; j++) {
          centers[j][0] = 0.0;
          centers[j][1] = 0.0;
          centers[j][2] = 0.0;
          int imanystoreys = 0;
          for (int i = 0; i < howmanyStoreys; i++) {
            if (ALLSTOREYS[i] == j) {
              G4ThreeVector StoPos = (*allmyStoreys)[i]->position;
              imanystoreys++;
              centers[j][0] += StoPos[0];
              centers[j][1] += StoPos[1];
              centers[j][2] += StoPos[2];
            }
          }
          if (imanystoreys > 1) {
            centers[j][0] /= double(imanystoreys);
            centers[j][1] /= double(imanystoreys);
            centers[j][2] /= double(imanystoreys);
          }
        }
      }
    } else
      nmove = 10; // the solution is not good and do again
  }

  //------------end of clustering---------------------------
  // load in linked list the benthos of each center
  std::vector<StoreysPositions *> *positivemyStoreys =
      new std::vector<StoreysPositions *>;
  std::vector<StoreysPositions *> *negativemyStoreys =
      new std::vector<StoreysPositions *>;
  for (int i = 0; i < howmanyStoreys; i++) {
    if (ALLSTOREYS[i] == 0) { // the first center
      positivemyStoreys->push_back((*allmyStoreys)[i]);
    } else { // the second center
      negativemyStoreys->push_back((*allmyStoreys)[i]);
    }
  }

  Spheres *mySphere1 = (Spheres *)malloc(sizeof(Spheres));
  splitSpheresCluster(positivemyStoreys, mySphere1);
  mySphere->allnext->push_back(mySphere1);
  depth--;
  Spheres *mySphere2 = (Spheres *)malloc(sizeof(Spheres));
  splitSpheresCluster(negativemyStoreys, mySphere2);
  mySphere->allnext->push_back(mySphere2);
  depth--;

  // here we delete the positivemyStoreys address list.
  positivemyStoreys->clear();
  delete positivemyStoreys;
  // here we delete the negativemyStoreys linked list.
  negativemyStoreys->clear();
  delete negativemyStoreys;
}

#endif
