#include "KM3EMFlux.hh"
#include "G4ExceptionHandler.hh"
#include "Randomize.hh"
#include "CLHEP/Random/RandGamma.h"
#include "CLHEP/Random/RandPoisson.h"
#include "CLHEP/Matrix/Matrix.h"
#include "CLHEP/Matrix/Vector.h"
#include <math.h>


KM3EMFlux::KM3EMFlux()
{
  zbinning=100.0;
  thetabinningdeg=0.1;
  thetabinningrad=thetabinningdeg*M_PI/180.0;
  M_PI2=2.0*M_PI;
}
KM3EMFlux::~KM3EMFlux()
{;}


void KM3EMFlux::Initialize() //reads data from files
{
  lamdacoeff = (4.136E-9 - 2.034E-9)*1000.0; //is the coefficient for the photon momentum emmision (MeV/c). Corresponds from 300 to 610 nm
  G4double tempo1,tempo2;
  G4int icount;
  FILE * inEMFile;
  if((inEMFile = fopen("EMData","r"))==NULL){
    G4Exception("Error open input Shower Data File\n");
  }
  else{
    fscanf(inEMFile,"%d\n",&NumOfEnergies);
    for(G4int ien=0 ; ien<NumOfEnergies ; ien++){
      fscanf(inEMFile,"%lf %lf\n",&tempo1,&tempo2);
      Energies[ien]=tempo1;
      MaxZ[ien]=tempo2;
      Zbins[ien]=int(tempo2/zbinning);
    }
    icount=0;
    for(G4int ien=0 ; ien<NumOfEnergies ; ien++){
      for(G4int iz=0 ; iz<Zbins[ien] ; iz++){
	IStart[ien][iz]=icount;
	for(G4int ith=0 ; ith<1800 ; ith++){
	  fscanf(inEMFile,"%lf %lf\n",&tempo1,&tempo2);
	  keepData.push_back(tempo1);
	  keepDatarms.push_back(tempo2*tempo2); //from now on this vector keeps the variance
	  icount++;
	}
      }
    }
  }
}

G4bool KM3EMFlux::ModelTrigger(G4double TheE)
{
  if(TheE<Energies[0] || TheE>Energies[NumOfEnergies-1])return false; //no extrapolation is used
  else return true;
}

void KM3EMFlux::SetEnergy(G4double TheE)
{
  Energy = TheE;
  for(ienbin2=0 ; ienbin2<NumOfEnergies ; ienbin2++)if(Energy<Energies[ienbin2])break;
  if(ienbin2==NumOfEnergies)ienbin2=NumOfEnergies-1;
  ienbin1=ienbin2-1;
  //the interpolation is for 4 total points. However we must keep at least 3 points above the energy in order to extrapolate for the zero bins
  if(ienbin1 ==0){ //first bin
    ienstart=ienbin1;
    ienstop=ienbin2+3;}
  else if(ienbin2 == NumOfEnergies-2){ //prelast bin
    ienstart=ienbin1-1;
    ienstop=ienbin2+2;}
  else if(ienbin2 == NumOfEnergies-1){ //last bin
    ienstart=ienbin1-2;
    ienstop=ienbin2+1;}
  else{                                 //intermediate bins
    ienstart=ienbin1-1;
    ienstop=ienbin2+3;
  }
}


G4int KM3EMFlux::GiveNum(G4double area, G4int zbin,G4double Distance,G4double Thetarad,G4double qe)
{
  G4double Fentries[100];
  G4double Fentriesrms[100];
  G4int thetabin,ibin1,ibin2;
  G4double Theta;
  G4double thbin1,thbin2;
  G4double coeff1,coeff2;
  G4double crms1,crms2;
  G4double f1,f2;
  G4int ibin;

  if(Thetarad == 0.0)return 0;
  if(zbin >= GiveMaxZbin() ) return 0;
  Theta=Thetarad*180.0/M_PI;
  ////////////////////////////////////////

  for(G4int ien=ienstart ; ien<ienstop ; ien++){
    if(zbin<Zbins[ien]){
      thetabin=int(Theta/thetabinningdeg);
      if(thetabin == 1799) thetabin=1798; //so that it does not get out of the valid bins
      ibin1=IStart[ien][zbin]+thetabin;
      ibin2=ibin1+1;
      f1=keepData[ibin1];
      f2=keepData[ibin2];
      //check for zero values flux
      //does not check for the case that there is only one bin with non zero value (rare?)
      if(f1 == 0){ //find a lower point
	for(ibin=ibin1-1 ; ibin>= IStart[ien][zbin] ; ibin--)if(keepData[ibin] > 0)break;
	if(ibin == (IStart[ien][zbin]-1)){ //no lower point found search for higher
	  for(ibin=ibin1+1 ; ibin<IStart[ien][zbin]+1800 ; ibin++)if(keepData[ibin] > 0)break;
	  if(ibin == IStart[ien][zbin]+1800)return 0; //this the case that no non-zero bin found
	}
	ibin1=ibin;
	f1=keepData[ibin1];
      }
      if(ibin1 >= ibin2){ //this is the case that no lower point found and the start is greater than the stop interval
	for(ibin=ibin1+1 ; ibin<IStart[ien][zbin]+1800 ; ibin++)if(keepData[ibin] > 0)break;
	if(ibin == IStart[ien][zbin]+1800)return 0; //this the case that no second non-zero bin found
	ibin2=ibin;
	f2=keepData[ibin2];
      }
      if(f2 == 0){ //find a higher point
	for(ibin=ibin2+1 ; ibin<IStart[ien][zbin]+1800 ; ibin++)if(keepData[ibin] > 0)break;
	if(ibin == IStart[ien][zbin]+1800)return 0; //this the case that no second non-zero bin found
	ibin2=ibin;
	f2=keepData[ibin2];
      }
      //thbin1=double(thetabin)*thetabinningdeg;
      thbin1=double(ibin1-IStart[ien][zbin])*thetabinningdeg +thetabinningdeg/2.0;
      //thbin2=thbin1+thetabinningdeg;
      thbin2=double(ibin2-IStart[ien][zbin])*thetabinningdeg +thetabinningdeg/2.0;
      //coeff2=(Theta-thbin1)/thetabinningdeg;
      coeff2=(Theta-thbin1)/(thbin2-thbin1);
      coeff1=1.0-coeff2;
      Fentries[ien]=coeff1*f1+coeff2*f2; //linear interpolation
      //if the interpolated flux is negative return 0. This case is too difficult to encounter generally.
      //Since we are talking about the angle and for any energies the angular flux does ont change drastically.
      if(Fentries[ien] <= 0){
	return 0;
      }
      //interpolate also the spread. if the resulting spread is negative, use the mean variance
      crms1=coeff1*keepDatarms[ibin1];
      crms2=coeff2*keepDatarms[ibin2];
      Fentriesrms[ien]=crms1+crms2;
      if(Fentriesrms[ien] <= 0)Fentriesrms[ien]=(keepDatarms[ibin1]+keepDatarms[ibin2])/2.0;
    }
    else{
      Fentries[ien]=0.0;
      Fentriesrms[ien]=0.0;
    }
  }
  G4int iss,ill;
  G4double Fentrieslog[4];
  G4double Fentriesrmslog[4];
  G4double Fenergieslog[4];
  G4double Energylog;
  G4int NumOfEnergiesInt=4;
  G4int polydegree=3;
  Energylog=log10(Energy);
  if((ienstop-ienstart) == 5){ //intermediate bins
    if(Fentries[ienstart] > 0){ // all ok
      iss=ienstart;
      ill=ienstop-1;
      for(G4int ibin=iss ; ibin<ill ; ibin++){
	Fenergieslog[ibin-iss]=log10(Energies[ibin]);
	Fentrieslog[ibin-iss]=log10(Fentries[ibin]);
	Fentriesrmslog[ibin-iss]=log10(Fentriesrms[ibin]);
      }
    }
    else{ //the first bin is zero
      iss=ienstart+1;
      ill=ienstop;
      for(G4int ibin=iss ; ibin<ill ; ibin++){
	Fenergieslog[ibin-iss]=log10(Energies[ibin]);
	Fentrieslog[ibin-iss]=log10(Fentries[ibin]);
	Fentriesrmslog[ibin-iss]=log10(Fentriesrms[ibin]);
      }
      if(Fentries[iss] == 0){//both 2 first bins are zero. In this case extrapolate the second bin
	if(!extrapolate(Fentrieslog,Fenergieslog)) return 0;
	if(!extrapolate(Fentriesrmslog,Fenergieslog)) return 0 ;
      }
    }
  }
  else{ // edge bins have 4 points 
    if(ienstart == ienbin1){ //first bin. ienbin1=0.
      iss=ienstart;
      ill=ienstop;
      for(G4int ibin=iss ; ibin<ill ; ibin++){
	Fenergieslog[ibin-iss]=log10(Energies[ibin]);
	Fentrieslog[ibin-iss]=log10(Fentries[ibin]);
	Fentriesrmslog[ibin-iss]=log10(Fentriesrms[ibin]);
      }
      if(Fentries[iss] == 0){ //first entry is zero. extrapolate
	if(!extrapolate(Fentrieslog,Fenergieslog)) return 0;
	if(!extrapolate(Fentriesrmslog,Fenergieslog)) return 0;
      }
    }
    else if(ienstart == (ienbin1-1)){ //prelast bin
      if(Fentries[ienstart+1] >0){
	iss=ienstart;
	ill=ienstop;
	for(G4int ibin=iss ; ibin<ill ; ibin++){
	  Fenergieslog[ibin-iss]=log10(Energies[ibin]);
	  Fentrieslog[ibin-iss]=log10(Fentries[ibin]);
	  Fentriesrmslog[ibin-iss]=log10(Fentriesrms[ibin]);
	}
	if(Fentries[iss] == 0){ //first entry is zero. extrapolate
	  if(!extrapolate(Fentrieslog,Fenergieslog)) return 0;
	  if(!extrapolate(Fentriesrmslog,Fenergieslog)) return 0;
	}
      }
      else{ //both start entries are zero. cannot extrapolate quadratically. extrapolate linearly
	iss=ienstart+2;
	ill=ienstop;
	for(G4int ibin=iss ; ibin<ill ; ibin++){
	  Fenergieslog[ibin-iss]=log10(Energies[ibin]);
	  Fentrieslog[ibin-iss]=log10(Fentries[ibin]);
	  Fentriesrmslog[ibin-iss]=log10(Fentriesrms[ibin]);
	}
	NumOfEnergiesInt=2;
	polydegree=1;
      }
    }
    else{ //last bin
      if(Fentries[ienstart+1] >0){
	iss=ienstart;
	ill=ienstop;
	for(G4int ibin=iss ; ibin<ill ; ibin++){
	  Fenergieslog[ibin-iss]=log10(Energies[ibin]);
	  Fentrieslog[ibin-iss]=log10(Fentries[ibin]);
	  Fentriesrmslog[ibin-iss]=log10(Fentriesrms[ibin]);
	}
	if(Fentries[iss] == 0){ //first entry is zero. extrapolate
	  if(!extrapolate(Fentrieslog,Fenergieslog)) return 0;
	  if(!extrapolate(Fentriesrmslog,Fenergieslog)) return 0;
	}
      }      
      else if(Fentries[ienstart+2] >0){ //both start entries are zero. cannot extrapolate quadratically. extrapolate linearly
	iss=ienstart+2;
	ill=ienstop;
	for(G4int ibin=iss ; ibin<ill ; ibin++){
	  Fenergieslog[ibin-iss]=log10(Energies[ibin]);
	  Fentrieslog[ibin-iss]=log10(Fentries[ibin]);
	  Fentriesrmslog[ibin-iss]=log10(Fentriesrms[ibin]);
	}
	//G4double slope=(Fentrieslog[1]-Fentrieslog[0])/(Fenergieslog[1]-Fenergieslog[0]);
	//printf("slope %d %f %f\n",zbin,Theta,slope);
	NumOfEnergiesInt=2;
	polydegree=1;
      }
      else{ // only the last entry is not zero.use the mean slope from above (0.91) with rms 0.5
	Fenergieslog[0]=log10(Energies[ienstop-2]);
	Fenergieslog[1]=log10(Energies[ienstop-1]);
	Fentrieslog[1]=log10(Fentries[ienstop-1]);
	Fentriesrmslog[1]=log10(Fentriesrms[ienstop-1]);
	G4double slope=G4RandGauss::shoot(0.91,0.5);
	G4double sloperms=G4RandGauss::shoot(0.91,0.5);
	Fentrieslog[0]=Fentrieslog[1]+slope*(Fenergieslog[0]-Fenergieslog[1]);
	Fentriesrmslog[0]=Fentriesrmslog[1]+sloperms*(Fenergieslog[0]-Fenergieslog[1]);
	NumOfEnergiesInt=2;
	polydegree=1;
      }
    }
  }    
  
  G4double dndth=divdif(Fentrieslog,Fenergieslog,NumOfEnergiesInt,Energylog,polydegree);
  //also interpolate the spread.
  G4double dndthrms=divdif(Fentriesrmslog,Fenergieslog,NumOfEnergiesInt,Energylog,polydegree);
  dndth=pow(10.0,dndth)/thetabinningrad;
  dndthrms=pow(10.0,dndthrms)/thetabinningrad;
  // rms according to the rms of the mean of the edges of the energy bin (rude).
  //G4double dndthrms=sqrt(Fentriesrms[ienbin1]*Fentriesrms[ienbin1]+Fentriesrms[ienbin2]*Fentriesrms[ienbin2])/thetabinningrad;
  G4double coeff=M_PI2*Distance*Distance*sin(Thetarad);
  G4double flux=dndth/coeff;   // it is dN/d(area)
  G4double fluxrms=dndthrms/coeff;
  //  printf("flux and rms %d %.3e %.3e %.3e\n",zbin,Theta,flux,fluxrms);
  G4double meannum=flux*area*qe;
  G4double rmsnum=fluxrms*area*qe;

//   G4double fluxrandom;
//   do{
//     fluxrandom = G4RandGauss::shoot(flux,fluxrms);}
//   while(fluxrandom < 0.0);
//next sample according to the Polya (also called Pascal or negative binomial) distribution
  G4int numofphotons;
  G4double deviation = rmsnum-meannum; // It is variance-mean.this should be >0 for polya, =0 for poisson.
  if(deviation < 0.001){ //this case is for poisson (the limiting case of polya as n->oo is the poisson).
    numofphotons = (G4int) CLHEP::RandPoisson::shoot(meannum);
  }
  else{
    G4double p=meannum/rmsnum; //this is mean/variance
    G4double n=meannum*meannum/deviation;
    G4double X = CLHEP::RandGamma::shoot(n,1.0);
    numofphotons = (G4int) CLHEP::RandPoisson::shoot(X*(1-p)/p);
  }
  //  printf("inside %le %le %d\n",meannum,rmsnum,numofphotons);
  return numofphotons;
}

//for the zero flux energies find the flux from the non zero fluxes for greater energies (function log(fl)=a*log(en)**2+b*log(en)+c, 3 points)
G4bool KM3EMFlux::extrapolate(G4double F[], G4double A[])
{
  CLHEP::HepMatrix M(3,3);
  M(1,1)=A[1]*A[1]; M(1,2)=A[1]; M(1,3)=1.0;
  M(2,1)=A[2]*A[2]; M(2,2)=A[2]; M(2,3)=1.0;
  M(3,1)=A[3]*A[3]; M(3,2)=A[3]; M(3,3)=1.0;
  CLHEP::HepVector B(3);
  B(1)=F[1];        B(2)=F[2];   B(3)=F[3];
  CLHEP::HepVector C = solve(M,B);
  F[0]=(C[0]*A[0]+C[1])*A[0]+C[2];
  //check that the value is less than F[1]
  if(F[0] > F[1] ){ //extrapolation does not work
    //if there are 2 falling values use them for linear extrapolation, else return 0
    if(F[1] < F[2]){
      F[0]=F[1]+(A[0]-A[1])*(F[2]-F[1])/(A[2]-A[1]);}
    else if(F[1] < F[3]){
      F[0]=F[1]+(A[0]-A[1])*(F[3]-F[1])/(A[3]-A[1]);}
    else if(F[2] < F[3]){
      F[0]=F[2]+(A[0]-A[2])*(F[3]-F[2])/(A[3]-A[2]);}
    else{
      printf("extrapolation failed");
      return false;
    }
  }
  return true;
}

G4int KM3EMFlux::GiveMaxZbin()
{
  return ( Zbins[ienbin1] >? Zbins[ienbin2]);
}


G4double KM3EMFlux::divdif(G4double F[], G4double A[], G4int NN, G4double X, G4int MM)
{
  G4double T[20];
  G4double D[20];
  G4bool EXTRA;
  G4int MMAX=10;
  G4int N,M,MPLUS,IX,IY;
  G4int MID,NPTS,IP,L;
  G4int ISUB,I,J;
  G4double SUM;
  //
  //  TABULAR INTERPOLATION USING SYMMETRICALLY PLACED ARGUMENT POINTS.
  //
  //  START.  FIND SUBSCRIPT IX OF X IN ARRAY A.
  if( (NN<2) || (MM<1) ) goto L20;
  N=NN;
  //  M=MIN(MM,MIN(MMAX,N-1));
  M= MM <? (MMAX <? (N-1));
  MPLUS=M+1;
  IX=0;
  IY=N+1;
  if(A[0]>A[N-1]) goto L4;
  //     (SEARCH INCREASING ARGUMENTS.)
 L1:
  MID=(IX+IY)/2;
  if(X >= A[MID-1]) goto L2;
  IY=MID;
  goto L3;
  //        (IF TRUE.)
 L2:
  IX=MID;
 L3:
  if((IY-IX)>1) goto L1;
  goto L7;
  //     (SEARCH DECREASING ARGUMENTS.)
 L4:
  MID=(IX+IY)/2;
  if(X<=A[MID-1]) goto L5;
  IY=MID;
  goto L6;
  //        (IF TRUE.)
 L5:
  IX=MID;
 L6:
  if((IY-IX)>1) goto L4;
  //
  //  COPY REORDERED INTERPOLATION POINTS INTO (T(I),D(I)), SETTING
  //  *EXTRA* TO TRUE IF M+2 POINTS TO BE USED.
 L7:
  NPTS=M+2-M%2;
  IP=0;
  L=0;
  goto L9;
 L8:
  L=-L;
  if(L>=0) L=L+1;
 L9:
  ISUB=IX+L;
  if((1<=ISUB) && (ISUB<=N)) goto L10;
  //        (SKIP POINT.)
  NPTS=MPLUS;
  goto L11;
  //        (INSERT POINT.)
 L10:
  IP=IP+1;
  T[IP-1]=A[ISUB-1];
  D[IP-1]=F[ISUB-1];
 L11:
  if(IP<NPTS) goto L8;
  EXTRA=(NPTS != MPLUS);
  //
  //  REPLACE D BY THE LEADING DIAGONAL OF A DIVIDED-DIFFERENCE TABLE, SUP-
  //  PLEMENTED BY AN EXTRA LINE IF *EXTRA* IS TRUE.
  for (L=1 ; L<=M ; L++){
    if(!EXTRA) goto L12;
    ISUB=MPLUS-L;
    D[M+1]=(D[M+1]-D[M-1])/(T[M+1]-T[ISUB-1]);
  L12:
    I=MPLUS;
    for(J=L ; J<=M ; J++){
      ISUB=I-L;
      D[I-1]=(D[I-1]-D[I-2])/(T[I-1]-T[ISUB-1]);
      I=I-1;
    }
  } 
  //
  //  EVALUATE THE NEWTON INTERPOLATION FORMULA AT X, AVERAGING TWO VALUES
  //  OF LAST DIFFERENCE IF *EXTRA* IS TRUE.
  SUM=D[MPLUS-1];
  if(EXTRA) SUM=0.5*(SUM+D[M+1]);
  J=M;
  for(L=1 ; L<=M ; L++){
    SUM=D[J-1]+(X-T[J-1])*SUM;
    J=J-1;
  }
  return SUM;
  ////////////////////////////////////////////////////////////////////////
 L20:
  printf("Error in KM3EMFlux::divdif. NN lt 2 or MM lt 1. Check it");
  return 0.0;
  
}

