
// Geometry Header File
// KM3Detector.hh generated by Geant4 Geometry Editor at Thu Apr 04 19:40:34
// GMT+03:00 2002

#ifndef KM3Detector_h
#define KM3Detector_h 1
#include "KM3Definitions.h"
#include <stdio.h>
#include <vector>
#include "KM3Cathods.hh"
#ifdef G4MYFIT_PARAMETERIZATION
#include "KM3EventAction.hh"
#endif
#include "KM3PrimaryGeneratorAction.hh"

#include "HOURSevtWRITE.hh"

class G4VPhysicalVolume;
#include "G4VUserDetectorConstruction.hh"
// newgeant #include "Saxana/SAXProcessor.h"
// newgeant #include "Saxana/ProcessingConfigurator.h"

class KM3Detector : public G4VUserDetectorConstruction {
public:
  KM3Detector();
  ~KM3Detector();

public:
  FILE *outfile;
  FILE *outfilePar;
  bool useANTARESformat;
  HOURSevtWRITE *TheEVTtoWrite;

  G4VPhysicalVolume *Construct();
  double Quantum_Efficiency;
  double bottomPosition;
  G4ThreeVector detectorCenter;
  double lowestStorey;
  double highestStorey;
  double outerStorey;
  double detectorRadius;
  // this is the maximum vertical distance of the storeys from the center plus a
  // number of absorpion lengths
  double detectorMaxz;
  // this is the maximum orizontal distance of the storeys plus a number of
  // absorption lengths
  double detectorMaxRho;
  std::vector<StoreysPositions *> *allStoreys;
  std::vector<OMPositions *> *allOMs;
#if !defined(G4MYEM_PARAMETERIZATION) && !defined(G4MYHA_PARAMETERIZATION)
  std::vector<TowersPositions *> *allTowers; // new towers
#endif
  KM3Cathods *allCathods;
  double MaxAbsDist;
  bool vrmlhits;
  bool DrawDetector;
  char *Geometry_File;
  char *Parameter_File;
  char *EMParametrization_FILE;
  char *HAParametrization_FILE;
  double TotCathodArea;
#ifdef G4MYFIT_PARAMETERIZATION
  KM3EventAction *event_action;
#endif
#if defined(G4MYEM_PARAMETERIZATION) || defined(G4MYHA_PARAMETERIZATION) // newha
  std::vector<long double> *myPhotonsNumber;
  std::vector<long double> *myPhotonsTime;
  std::vector<long double> *myPhotonsTh2Th3Num;
  std::vector<long double> *myPhotonsTh2;
  std::vector<long double> *myPhotonsTh3;
#endif
  KM3PrimaryGeneratorAction *MyGenerator;

private:
  void FindDetectorRadius(void);
  void ConstructMaterials(void);
  int TotalPMTEntities(const G4VPhysicalVolume *) const;
  void SetUpVariables(void);
// newgeant  void sxpInitialize(void);
#if !defined(G4ENABLE_MIE) ||                                                  \
    (defined(G4ENABLE_MIE) && !defined(G4DISABLE_PARAMETRIZATION)) // newmie
public:
  Spheres *allSpheres; // keep the spheres used in KM3Cherenkov
private:
  void initializeSpheres(void);
  void splitSpheresCluster(std::vector<StoreysPositions *> *, Spheres *);
  int howmanySpheres; // this is used in clustering method of splitSpheres
  int ALLSTOREYS[1000000]; // this is used in clustering method of
                             // splitSpheres
#endif
private:
  // newgeant  SAXProcessor sxp;
  // newgeant ProcessingConfigurator config;
  G4VPhysicalVolume *fWorld;

private:
  double detectorDepth;
  int NUMENTRIES;
  int NUMENTRIES_ANGLEACC;
  double PPCKOV[100];
  double RINDEX_WATER[100];
  double Water_Transparency;
  double ABSORPTION_WATER[100];
#if (defined(G4MYEM_PARAMETERIZATION) || defined(G4MYHA_PARAMETERIZATION)) &&  \
    !defined(G4MYK40_PARAMETERIZATION)
  double ABSORPTION_WATER_TRUE[100];
#endif
  double ABSORPTION_GLASS[100];
  double RINDEX_GLASS[100];
  double ABSORPTION_GELL[100];
  double RINDEX_GELL[100];
  double ABSORPTION_AIR[100];
  double RINDEX_AIR[100];
  double ABSORPTION_CATH[100];
  double RINDEX_CATH[100];
  double Q_EFF[100];
  double SCATTER_WATER[100];
  double MieModel;
  double COSANGLES[100];
  double ACCEPTANCE[100];
};
#endif
